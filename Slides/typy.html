<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<h1 id="plan-wyk&#322;adu">Plan wykładu</h1>
<ul>
<li>Typy i klasy (ok. 3 wykładów)
<ul>
<li>Typy algebraiczne i klasy typów</li>
<li>Klasy konstruktorowe</li>
<li>Klasy wieloparametrowe, zależności funkcyjne</li>
<li>Rodziny typów, typy skojarzone, uogólnione typy algebraiczne (GADT)</li>
</ul></li>
<li>Metody kontrolowania efektów w języku funkcyjnym (ok. 6 wykładów)
<ul>
<li>Rodzaje efektów (błędy, stan, I/O, nawracanie)</li>
<li>Monady Error, State, IO, List</li>
<li>Studium biblioteki monadycznej</li>
<li>Funktory aplikatywne i idiomy</li>
<li>Studium biblioteki idiomatycznej</li>
<li>Strzałki</li>
</ul></li>
<li>Programowanie równoległe w Haskellu
<ul>
<li>Programowanie wielordzeniowe i wieloprocesorowe (SMP)</li>
<li>Równoległość danych (Data Parallel Haskell)</li>
</ul></li>
<li>Prezentacje projektów</li>
</ul>
<h1 id="j&#281;zyki-funkcyjne">Języki funkcyjne</h1>
<ul>
<li>typowane dynamicznie, gorliwe: Lisp</li>
<li>typowane statycznie, gorliwe, nieczyste: ML</li>
<li>typowane statycznie, leniwe, czyste: Haskell</li>
</ul>
<p>Types are a design language - SPJ</p>
<h1 id="typy-w-haskellu">Typy w Haskellu</h1>
<ul>
<li>typy bazowe: <code>zeroInt :: Int</code></li>
<li>typy funkcyjne: <code>plusInt :: Int -&gt; Int -&gt; Int</code></li>
<li><p>typy polimorficzne <code>id :: a -&gt; a</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span><br /><span class="ot">g </span><span class="ot">::</span> forall b<span class="fu">.</span>b <span class="ot">-&gt;</span> b</code></pre></li>
<li><p>typy algebraiczne</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Node</span> a (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</code></pre></li>
<li><p>NB od niedawna Haskell dopuszcza puste typy:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Zero</span></code></pre></li>
<li><p><code>Tree</code> jest <em>konstruktorem typowym</em>, czyli operacją na typach</p></li>
</ul>
<h1 id="operacje-na-typach">Operacje na typach</h1>
<ul>
<li><p>Konstruktory typowe transformują typy</p></li>
<li><p><code>Tree</code> może zamienić np. <code>Int</code> w drzewo</p></li>
</ul>
<h1 id="klasy">Klasy</h1>
<ul>
<li><p>klasy opisują własności typów</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Eq</span> a <span class="kw">where</span><br /><span class="ot">  (==) </span><span class="ot">::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span><br /><span class="kw">instance</span> <span class="kw">Eq</span> <span class="dt">Bool</span> <span class="kw">where</span><br />   <span class="kw">True</span>  <span class="fu">==</span> <span class="kw">True</span>  <span class="fu">=</span> <span class="kw">True</span><br />   <span class="kw">False</span> <span class="fu">==</span> <span class="kw">False</span> <span class="fu">=</span> <span class="kw">True</span><br />   _     <span class="fu">==</span> _     <span class="fu">=</span> <span class="kw">False</span></code></pre></li>
</ul>
<h1 id="typy-jako-j&#281;zyk-specyfikacji">Typy jako język specyfikacji</h1>
<p>Typ funkcji często specyfikuje nie tylko jej wejście i wyjście ale i relacje między nimi:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">f </span><span class="ot">::</span> forall a<span class="fu">.</span> a <span class="ot">-&gt;</span> a<br />f x <span class="fu">=</span> <span class="fu">?</span></code></pre>
<p>Jeśli <code>(f x)</code> daje wynik, to musi nim być <code>x</code></p>
<ul>
<li><p>Philip Wadler &quot;Theorems for Free&quot;</p></li>
<li><p>Funkcja typu <code>a -&gt; IO b</code> może mieć efekty uboczne</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Data.IORef</span><br /><br /><span class="ot">f </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IORef</span> <span class="dt">Int</span>)<br />f i <span class="fu">=</span> <span class="kw">do</span><br />  <span class="fu">print</span> i<br />  r <span class="ot">&lt;-</span> newIORef i<br />  <span class="fu">return</span> r<br /><br />main <span class="fu">=</span> <span class="kw">do</span><br />  r <span class="ot">&lt;-</span> f <span class="dv">42</span><br />  j <span class="ot">&lt;-</span> readIORef r<br />  <span class="fu">print</span> j    </code></pre></li>
</ul>
<h1 id="typy-jako-j&#281;zyk-specyfikacji-2">Typy jako język specyfikacji (2)</h1>
<p>Funkcja typu <code>Integer -&gt; Integer</code> zasadniczo nie może mieć efektów ubocznych</p>
<p>Liczby Fibonacciego w stałej pamięci</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Control.Monad.ST</span><br /><span class="kw">import</span> <span class="dt">Data.STRef</span><br /><span class="ot">fibST </span><span class="ot">::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span><br />fibST n <span class="fu">=</span> <br />    <span class="kw">if</span> n <span class="fu">&lt;</span> <span class="dv">2</span> <span class="kw">then</span> n <span class="kw">else</span> runST fib2 <span class="kw">where</span><br />      fib2 <span class="fu">=</span>  <span class="kw">do</span><br />        x <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span><br />        y <span class="ot">&lt;-</span> newSTRef <span class="dv">1</span><br />        fib3 n x y<br /><br />      fib3 <span class="dv">0</span> x _ <span class="fu">=</span> readSTRef x<br />      fib3 n x y <span class="fu">=</span> <span class="kw">do</span><br />              x' <span class="ot">&lt;-</span> readSTRef x<br />              y' <span class="ot">&lt;-</span> readSTRef y<br />              writeSTRef x y'<br />              writeSTRef y (x'<span class="fu">+</span>y')<br />              fib3 (n<span class="fu">-</span><span class="dv">1</span>) x y</code></pre>
<p>Jak to?</p>
<pre><code>runST :: (forall s. ST s a) -&gt; a
</code></pre>
<p>Typ <code>runST</code> gwarantuje, że efekty uboczne nie wyciekają. Funkcja <code>fibST</code> jest czysta.</p>
<h1 id="typy-jako-j&#281;zyk-projektowania">Typy jako język projektowania</h1>
<ul>
<li><p>Projektowanie programu przy użyciu typów i <code>undefined</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">conquer </span><span class="ot">::</span> [<span class="dt">Foo</span>] <span class="ot">-&gt;</span> [<span class="dt">Bar</span>]<br />conquer fs <span class="fu">=</span> <span class="fu">concatMap</span> step fs<br /><br /><span class="ot">step </span><span class="ot">::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> [<span class="dt">Bar</span>]<br />step <span class="fu">=</span> <span class="fu">undefined</span></code></pre></li>
</ul>
<h1 id="typy-jako-j&#281;zyk-programowania">Typy jako język programowania</h1>
<ul>
<li><p>Funkcje na typach obliczane w czasie kompilacji</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Zero</span><br /><span class="kw">data</span> <span class="dt">Succ</span> n<br /><br /><span class="kw">type</span> <span class="dt">One</span>   <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Zero</span><br /><span class="kw">type</span> <span class="dt">Two</span>   <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">One</span><br /><span class="kw">type</span> <span class="dt">Three</span> <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Two</span><br /><span class="kw">type</span> <span class="dt">Four</span>  <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Three</span><br /><br />one   <span class="fu">=</span><span class="ot"> undefined </span><span class="ot">::</span> <span class="dt">One</span><br />two   <span class="fu">=</span><span class="ot"> undefined </span><span class="ot">::</span> <span class="dt">Two</span><br />three <span class="fu">=</span><span class="ot"> undefined </span><span class="ot">::</span> <span class="dt">Three</span><br />four  <span class="fu">=</span><span class="ot"> undefined </span><span class="ot">::</span> <span class="dt">Four</span><br /><br /><span class="kw">class</span> <span class="dt">Add</span> a b c <span class="fu">|</span> a b <span class="ot">-&gt;</span> c <span class="kw">where</span><br /><span class="ot">  add </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c<br />  add <span class="fu">=</span> <span class="fu">undefined</span><br /><span class="kw">instance</span>              <span class="dt">Add</span>  <span class="dt">Zero</span>    b  b<br /><span class="kw">instance</span> <span class="dt">Add</span> a b c <span class="ot">=&gt;</span> <span class="dt">Add</span> (<span class="dt">Succ</span> a) b (<span class="dt">Succ</span> c)</code></pre>
<pre><code>*Main&gt; :t add three one
add three one :: Succ (Succ (Succ (Succ Zero)))
</code></pre></li>
<li><p>Ćwiczenie: rozszerzyć o mnożenie i silnię</p></li>
</ul>
<h1 id="typy-jako-j&#281;zyk-programowania-2">Typy jako język programowania (2)</h1>
<p>Wektory przy użyciu klas:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> </span><span class="ot">::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span><br />  <span class="dt">VNil</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a  <br /><span class="ot">  (:&gt;) </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a<br /><br /><span class="ot">vhead </span><span class="ot">::</span> <span class="dt">Vec</span> (<span class="dt">Succ</span> n) a <span class="ot">-&gt;</span> a<br />vhead (x <span class="fu">:&gt;</span> xs) <span class="fu">=</span> x</code></pre>
<p><strong>Ćwiczenie:</strong> dopisać <code>vtail</code>, <code>vlast</code></p>
<p>Chcielibyśmy również mieć</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">vappend </span><span class="ot">::</span> <span class="dt">Add</span> m n s <span class="ot">=&gt;</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> s a</code></pre>
<p>ale tu niestety system typów okazuje się za słaby</p>
<h1 id="typy-jako-j&#281;zyk-programowania-3">Typy jako język programowania (3)</h1>
<ul>
<li><p>Wektory przy użyciu rodzin typów:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Zero</span><br /><span class="kw">data</span> <span class="dt">Suc</span> n <span class="fu">=</span> <span class="dt">Suc</span> n<br /><br /><span class="kw">type</span> family m <span class="fu">:+</span> n<br /><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Zero</span> <span class="fu">:+</span> n <span class="fu">=</span> n<br /><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Suc</span> m) <span class="fu">:+</span> n <span class="fu">=</span> <span class="dt">Suc</span>(m<span class="fu">:+</span>n)<br /><br /><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> </span><span class="ot">::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="kw">where</span><br />  <span class="dt">VNil</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a  <br /><span class="ot">  (:&gt;) </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a<br /><br /><span class="ot">vhead </span><span class="ot">::</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a <span class="ot">-&gt;</span> a<br /><span class="ot">vappend </span><span class="ot">::</span> <span class="dt">Vec</span> m a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (m<span class="fu">:+</span>n) a</code></pre></li>
<li><p>Sprytna sztuczka o wątpliwej wartości praktycznej</p></li>
</ul>
<h1 id="podklasy">Podklasy</h1>
<ul>
<li><p>Jeśli typ a jest klasy C i są zdefiniowane funkcje ... to jest klasy D</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Eq</span> a <span class="ot">=&gt;</span> <span class="kw">Ord</span> a <span class="kw">where</span><br /><span class="ot">  compare </span><span class="ot">::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span><br /><span class="ot">  (&lt;) </span><span class="ot">::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span><br />  <span class="fu">...</span></code></pre></li>
<li><p>Graf podklas musi być acykliczny</p></li>
<li><p>Specyfikowanie nadklas jest kwestią smaku - można dyskutować, czy <code>Eq</code> rzeczywiście jest niezbędne dla <code>Ord</code>, albo czy każda instancja <code>Monad</code> musi być instancją <code>Functor</code>.</p></li>
</ul>
<h1 id="klasy-konstruktorowe">Klasy konstruktorowe</h1>
<ul>
<li><p>klasy konstruktorowe opisują własności konstruktorów typów</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="kw">where</span><br /><span class="ot">  fmap </span><span class="ot">::</span> (a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre></li>
</ul>
<h1 id="rodzaje-kinds">Rodzaje (kinds)</h1>
<ul>
<li><p>Operacje na wartościach są opisywane przez ich typy</p></li>
<li><p>Operacje na typach są opisywane przez ich rodzaje (kinds)</p></li>
<li><p>Typy (np. <code>Int</code>) są rodzaju <code>*</code></p></li>
<li><p>Jednoargumentowe konstruktory (np. <code>Tree</code>) są rodzaju <code>* -&gt; *</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-#LANGUAGE KindSignatures, ExplicitForAll #-}</span><br /><br /><span class="kw">class</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Pointed</span> (<span class="ot">f </span><span class="ot">::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span><br /><span class="ot">    pure </span><span class="ot">::</span> forall (<span class="ot">a </span><span class="ot">::</span> <span class="fu">*</span>)<span class="fu">.</span>a <span class="ot">-&gt;</span> f a</code></pre></li>
<li><p>Występują też bardziej złożone rodzaje, np. dla transformatorów monad:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> (<span class="ot">t </span><span class="ot">::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span><br /><span class="ot">    lift </span><span class="ot">::</span> <span class="kw">Monad</span> (<span class="ot">m </span><span class="ot">::</span> <span class="fu">*</span>) <span class="ot">=&gt;</span> forall (<span class="ot">a </span><span class="ot">::</span> <span class="fu">*</span>)<span class="fu">.</span>m a <span class="ot">-&gt;</span> t m a</code></pre></li>
</ul>
<p>NB spacje są niezbędne - <code>::*-&gt;*</code> jest jednym leksemem.</p>
<h1 id="klasy-wieloparametrowe">Klasy wieloparametrowe</h1>
<ul>
<li><p>Czasami potrzebujemy opisać nie tyle pojedynczy typ, co relacje między typami:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-#LANGUAGE MultiParamTypeClasses, FlexibleInstances #-}</span><br /><span class="kw">class</span> <span class="dt">Iso</span> a b <span class="kw">where</span><br /><span class="ot">  iso </span><span class="ot">::</span> a <span class="ot">-&gt;</span> b<br /><span class="ot">  osi </span><span class="ot">::</span> b <span class="ot">-&gt;</span> a<br /><br /><span class="kw">instance</span> <span class="dt">Iso</span> a a <span class="kw">where</span><br />  iso <span class="fu">=</span> <span class="fu">id</span><br />  osi <span class="fu">=</span> <span class="fu">id</span><br /><br /><span class="kw">instance</span> <span class="dt">Iso</span> ((a,b)<span class="ot">-&gt;</span>c) (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c) <span class="kw">where</span><br />  iso <span class="fu">=</span> <span class="fu">curry</span><br />  osi <span class="fu">=</span> <span class="fu">uncurry</span><br /><br /><span class="kw">instance</span> (<span class="dt">Iso</span> a b) <span class="ot">=&gt;</span> <span class="dt">Iso</span> [a] [b] <span class="kw">where</span><br /> iso <span class="fu">=</span> <span class="fu">map</span> iso<br /> osi <span class="fu">=</span> <span class="fu">map</span> osi</code></pre></li>
<li><p>Uwaga: w ostatnim przykładzie <code>iso</code> ma inny typ po lewej, inny po prawej</p></li>
<li><p>Ćwiczenie: napisz jeszcze jakieś instancje klasy <code>Iso</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="kw">Functor</span> f, <span class="dt">Iso</span> a b) <span class="ot">=&gt;</span> <span class="dt">Iso</span> (f a) (f b) <span class="kw">where</span> <br /><span class="kw">instance</span> <span class="dt">Iso</span> (a<span class="ot">-&gt;</span>b<span class="ot">-&gt;</span>c) (b<span class="ot">-&gt;</span>a<span class="ot">-&gt;</span>c) <span class="kw">where</span></code></pre></li>
</ul>
<h1 id="zale&#380;no&#347;ci-funkcyjne">Zależności funkcyjne</h1>
<p>Czasami w klasach wieloparametrowych, jeden parametr wyznacza inny, np.</p>
<pre class="sourceCode"><code class="sourceCode haskell"> <span class="kw">class</span> (<span class="kw">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s m <span class="fu">|</span> m <span class="ot">-&gt;</span> s <span class="kw">where</span> <span class="fu">...</span><br /><br /> <span class="kw">class</span> <span class="dt">Collects</span> e ce <span class="fu">|</span> ce <span class="ot">-&gt;</span> e <span class="kw">where</span><br /><span class="ot">      empty  </span><span class="ot">::</span> ce<br /><span class="ot">      insert </span><span class="ot">::</span> e <span class="ot">-&gt;</span> ce <span class="ot">-&gt;</span> ce<br /><span class="ot">      member </span><span class="ot">::</span> e <span class="ot">-&gt;</span> ce <span class="ot">-&gt;</span> <span class="dt">Bool</span></code></pre>
<h1 id="rodziny-typ&#243;w">Rodziny typów</h1>
<h1 id="generalised-algebraic-data-types-gadt">Generalised Algebraic Data Types (GADT)</h1>
<p>Rozważmy typowy typ algebraiczny:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Foo</span> a <span class="fu">=</span> <span class="dt">Bar</span> <span class="fu">|</span> <span class="dt">Baz</span> a (<span class="dt">Foo</span> a) </code></pre>
<p>alternatywnie można go zapisać wypisując typy konstruktorów:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span><br /><span class="kw">data</span> <span class="dt">Foo</span> a <span class="kw">where</span><br />  <span class="dt">Bar</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Foo</span> a<br />  <span class="dt">Baz</span><span class="ot"> </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">Foo</span> a <span class="ot">-&gt;</span> <span class="dt">Foo</span> a</code></pre>
<pre><code>*Main&gt; :t Baz () Bar
Baz () Bar :: Foo ()
*Main&gt; :t Mar () Mud
Mar () Mud :: Moo Int
</code></pre>
<h1 id="generalised-algebraic-data-types-gadt-1">Generalised Algebraic Data Types (GADT)</h1>
<p>Trochę ciekawszy przykład:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> <span class="fu">=</span> <span class="dt">ALitInt</span> <span class="dt">Int</span> <span class="fu">|</span> <span class="dt">ALitStr</span> <span class="dt">String</span> <span class="fu">|</span> <span class="dt">APlus</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="kw">deriving</span>(<span class="kw">Eq</span>,<span class="kw">Show</span>)<br /><span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span><br />  <span class="dt">ELitInt</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span><br />  <span class="dt">ELitStr</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">String</span><br />  <span class="dt">EPlus</span><span class="ot"> </span><span class="ot">::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a<br /><br /><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span>  <br /><span class="kw">deriving</span> <span class="kw">instance</span> <span class="kw">Show</span> a <span class="ot">=&gt;</span> <span class="kw">Show</span>(<span class="dt">Expr</span> a)  <br /><br /><span class="ot">interpret </span><span class="ot">::</span> <span class="dt">HasPlus</span> a <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a<br />interpret (<span class="dt">ELitInt</span> i) <span class="fu">=</span> i<br />interpret (<span class="dt">ELitStr</span> s) <span class="fu">=</span> s<br />interpret (<span class="dt">EPlus</span> e1 e2) <span class="fu">=</span> plus (interpret e1) (interpret e2)</code></pre>
<pre><code>*Gadt&gt; interpret $ EPlus (ELitInt 40) (ELitInt 2)
42
*Gadt&gt; :t APlus (ALitStr &quot;foo&quot;) (ALitInt 42)
APlus (ALitStr &quot;foo&quot;) (ALitInt 42) :: Exp
*Gadt&gt; :t EPlus (ELitStr &quot;foo&quot;) (ELitInt (42::Int))
    Couldn't match expected type `String' with actual type `Int'...
</code></pre>
<p><strong>Ćwiczenie:</strong> napisz ciekawszy interpreter dla wersji Exp i Expr</p>
<h1 id="koniec">Koniec</h1>
<p>Finis coronat opus.</p>
<pre><code>~~~~ {.haskell}

~~~~
</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"></code></pre>
</body>
</html>
