<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<h1 id="funktory">Funktory</h1>
<p>Funktor to operacja <code>T :: * -&gt; *</code> na typach<br />wraz z operacją <code>fmap</code> na funkcjach</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">fmap</span><span class="ot"> </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">T</span> a <span class="ot">-&gt;</span> <span class="dt">T</span> b) </code></pre>
<p>zachowującą strukturę składania funkcji, czyli</p>
<pre><code>fmap id = id
fmap (f . g) = fmap f . fmap g
</code></pre>
<h1 id="monady">Monady</h1>
<p>Monada to konstruktor typów <code>M</code>, z operacjami</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">return</span><span class="ot"> </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">M</span> a<br /><span class="ot">(&gt;&gt;=)  </span><span class="ot">::</span> <span class="dt">M</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span>  <span class="dt">M</span> b) <span class="ot">-&gt;</span> <span class="dt">M</span> b</code></pre>
<p>Elementami typu <code>M a</code> są obliczenia dające wynik typu <code>a</code> (z potencjalnymi efektami ubocznymi)</p>
<ul>
<li><code>return x</code> to obliczenie czyste</li>
<li><p><code>&gt;&gt;=</code> sekwencjonuje obliczenie z jego kontynuacją, np.</p>
<pre class="sourceCode"><code class="sourceCode haskell">readChan stdin <span class="fu">&gt;&gt;=</span>   (\userInput <span class="ot">-&gt;</span> <span class="fu">...</span> )</code></pre></li>
</ul>
<p>Każda monada jest/powinna być funktorem. To, że Functor nie jest nadklasą Monad jest li tylko zaszłością.</p>
<h1 id="prawa-monadyki">Prawa monadyki</h1>
<p>Każda monada musi spełniać następujące prawa:</p>
<pre><code>   1. (return x) &gt;&gt;= k == k x
   2. m &gt;&gt;= return == m
   3. (m &gt;&gt;= f) &gt;&gt;= g == m &gt;&gt;= (\x -&gt; (f x &gt;&gt;= g))
</code></pre>
<p>Pierwsze dwa prawa mówią, że <code>return</code> nie ma efektów; jest elementem neutralnym dla <code>(&gt;&gt;=)</code></p>
<p>Trzecie prawo mówi, że sekwencjonowanie obliczeń jest łączne, czyli w pewnym sensie, że</p>
<pre><code> (o1;o2);o3 === o1;(o2;o3)
</code></pre>
<p>...i możemy je traktować jako sekwencję <code>o1;o2;o3</code></p>
<h1 id="prawa-monadyki-inaczej">Prawa monadyki, inaczej</h1>
<pre><code>(&gt;=&gt;)       :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)
f &gt;=&gt; g     = \x -&gt; (f x &gt;&gt;= g)

1. return &gt;=&gt; g     = g
2. f &gt;=&gt; return     = f
3. (f &gt;=&gt; g) &gt;=&gt; h  = f &gt;=&gt; (g &gt;=&gt; h)
</code></pre>
<h1 id="inna-prezentacja-monad">Inna prezentacja monad</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Monad'</span> m <span class="kw">where</span><br /><span class="ot">   pure  </span><span class="ot">::</span>  a <span class="ot">-&gt;</span> m a<br /><span class="co">-- fmap  :: (a -&gt; b) -&gt; m a -&gt; m b</span><br /><span class="co">-- fmap g . pure === pure . g</span><br /><br /><span class="ot">  join </span><span class="ot">::</span> m (m a) <span class="ot">-&gt;</span> m a<br /><span class="co">-- join . fmap pure === id === join . pure</span><br /><span class="co">-- join . fmap join === join . join</span></code></pre>
<p>gdzie ta ostatnia równość jest w typie <code>m(m(m a)) -&gt; m a</code></p>
<h1 id="trywialny-funktor">Trywialny funktor</h1>
<p>http://blog.sigfpe.com/2007/04/trivial-monad.html (Dan Piponi, @sigfpe)</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">W</span> a <span class="fu">=</span> <span class="dt">W</span> a <span class="kw">deriving</span> <span class="kw">Show</span><br /><br /><span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">W</span> <span class="kw">where</span><br />  <span class="co">-- fmap :: (a -&gt; b) -&gt; W a -&gt; W b</span><br />  <span class="fu">fmap</span> f (<span class="dt">W</span> a) <span class="fu">=</span> <span class="dt">W</span> (f a)<br /><br /><span class="kw">class</span> <span class="dt">Pointed</span> f <span class="kw">where</span><br /><span class="ot">  pure </span><span class="ot">::</span> a <span class="ot">-&gt;</span> f a<br /><br /><span class="kw">instance</span> <span class="dt">Pointed</span> <span class="dt">W</span> <span class="kw">where</span><br />  pure <span class="fu">=</span> <span class="dt">W</span><br /><br />a,<span class="ot"> b </span><span class="ot">::</span> <span class="dt">W</span> <span class="dt">Int</span><br />a <span class="fu">=</span> pure <span class="dv">1</span><br />b <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">+</span><span class="dv">1</span>) a<br /><span class="co">-- zapakowan&#261; warto&#347;&#263; mo&#380;emy wielokrotnie zwi&#281;ksza&#263;:</span><br />s <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">+</span><span class="dv">1</span>)<br />t <span class="fu">=</span> s(s(a))</code></pre>
<h1 id="trywialna-monada">Trywialna monada</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">f </span><span class="ot">::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">W</span> <span class="dt">Int</span><br />f x <span class="fu">=</span> <span class="dt">W</span> (x<span class="fu">+</span><span class="dv">1</span>)<br /><span class="co">-- Jak zastosowa&#263; f dwukrotnie?</span><br /><br /><span class="ot">bind </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> <span class="dt">W</span> b) <span class="ot">-&gt;</span> (<span class="dt">W</span> a <span class="ot">-&gt;</span> <span class="dt">W</span> b)<br />bind f (<span class="dt">W</span> a) <span class="fu">=</span> f a<br /><br />c <span class="fu">=</span> bind f (f <span class="dv">1</span>)<br /><br /><span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">W</span> <span class="kw">where</span><br />  <span class="fu">return</span> <span class="fu">=</span> <span class="dt">W</span><br />  (<span class="dt">W</span> x) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f x</code></pre>
<p><strong>Ćwiczenia</strong></p>
<pre><code>g :: Int -&gt; W Int -&gt; W Int  -- g x (W y) = W (x+y), ale bez rozpakowywania
g x wy = undefined

h :: W Int -&gt; W Int -&gt; W Int --h (W x) (W y) = W (x+y), bez rozpakowywania
h wx wy = undefined

-- Udowodnij, że W spełnia prawa monadyki

join :: W (W a) -&gt; W a -- bez rozpakowywania, tylko return i bind
join wwa = undefined
</code></pre>
<h1 id="funktory-par">Funktory par</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Dla dowolnego c operacja \ a -&gt; (a,c) jest funktorem:</span><br /><span class="ot">first </span><span class="ot">::</span> (a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> (a,c) <span class="ot">-&gt;</span> (b,c)<br />first f (a,c) <span class="fu">=</span> (f a, c)<br /><br /><span class="co">-- podobnie \b -&gt; (c,b)</span><br /><span class="ot">second </span><span class="ot">::</span> (b<span class="ot">-&gt;</span>d) <span class="ot">-&gt;</span> (c,b) <span class="ot">-&gt;</span> (c,d)  <br />second f (c,b) <span class="fu">=</span> (c, f b)<br /><br /><span class="ot">(&amp;&amp;&amp;) </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (b,c)<br />f <span class="fu">&amp;&amp;&amp;</span> g <span class="fu">=</span> \a <span class="ot">-&gt;</span> (f a, g a)<br /><span class="co">-- first f = f &amp;&amp;&amp; id</span><br /><span class="co">-- second f = id &amp;&amp;&amp; f</span></code></pre>
<p>Ale czy potrafimy napisać funkcję typu <code>forall a c. a -&gt; (a,c)</code> ?</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">p1 </span><span class="ot">::</span> <span class="dt">Monoid</span> c <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (a,c)<br />p1 a <span class="fu">=</span> (a,mempty)</code></pre>
<h1 id="monada-stanu">Monada stanu</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">S</span> <span class="fu">=</span> <span class="dt">Int</span>  <span class="co">-- przyk&#322;adowo</span><br /><span class="kw">type</span> <span class="dt">SM</span> a <span class="fu">=</span> <span class="dt">S</span> <span class="ot">-&gt;</span> (a,<span class="dt">S</span>)<br /><br /><span class="co">-- Nie mo&#380;na napisa&#263; instance Functor SM ...</span><br /><span class="ot">smap </span><span class="ot">::</span> (a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> (<span class="dt">SM</span> a <span class="ot">-&gt;</span> <span class="dt">SM</span> b)<br />smap f t <span class="fu">=</span> first f <span class="fu">.</span> t <span class="co">-- \s -&gt; first f (t s)</span><br /><br /><span class="ot">spure </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">SM</span> a<br />spure a s <span class="fu">=</span> (a, s)<br /><span class="co">-- spure = (,)</span><br /><br /><span class="ot">sbind </span><span class="ot">::</span> <span class="dt">SM</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">SM</span> b) <span class="ot">-&gt;</span> <span class="dt">SM</span> b<br />sbind f k <span class="fu">=</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (a,s') <span class="fu">=</span> f s <span class="kw">in</span> k a s'<br /><br /><span class="ot">sjoin </span><span class="ot">::</span> <span class="dt">SM</span> (<span class="dt">SM</span> a) <span class="ot">-&gt;</span> <span class="dt">SM</span> a<br /><span class="co">-- sjoin :: (S -&gt; (S -&gt; (a,S),S)) -&gt; S -&gt; (a,S)</span><br />sjoin mma <span class="fu">=</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (ma,s') <span class="fu">=</span> mma s <span class="kw">in</span> ma s'<br /><br /><span class="co">-- uncurry ($) :: (b -&gt; c, b) -&gt; c</span><br /><span class="ot">sjoin' </span><span class="ot">::</span> <span class="dt">SM</span> (<span class="dt">SM</span> a) <span class="ot">-&gt;</span> <span class="dt">SM</span> a<br /><span class="co">-- sjoin' mma = \s -&gt; let (ma, s') = mma s in ma s'</span><br /><span class="co">-- sjoin' mma = \s -&gt; uncurry ($) (mma s)</span><br />sjoin' mma <span class="fu">=</span> <span class="fu">uncurry</span> (<span class="fu">$</span>) <span class="fu">.</span> mma</code></pre>
<h1 id="monada-state">Monada State</h1>
<p>Jesli chcemy zrobić porządną instancję <code>Monad</code> musimy opakować to wszystko w newtype:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState </span><span class="ot">::</span> s <span class="ot">-&gt;</span> (a, s) }<br /><br /><span class="kw">instance</span> <span class="kw">Functor</span> (<span class="dt">State</span> s) <span class="kw">where</span><br />    <span class="fu">fmap</span> f m <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span><br />        (a, s') <span class="fu">=</span> runState m s<br />        <span class="kw">in</span> (f a, s')<br /><br /><span class="kw">instance</span> <span class="kw">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span><br />    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (a, s)<br />    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span><br />        (a, s') <span class="fu">=</span> runState m s<br />        <span class="kw">in</span> runState (k a) s'</code></pre>
<h1 id="stan-a-lenistwo">Stan a lenistwo</h1>
<p>Możemy zapisać instancje Functor i Monad trochę inaczej:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Functor</span> (<span class="dt">State</span> s) <span class="kw">where</span><br />    <span class="fu">fmap</span> f m <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runState m s <span class="kw">of</span><br />                                 (a, s') <span class="ot">-&gt;</span> (f a, s')<br /><span class="kw">instance</span> <span class="kw">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span><br />    <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> (a, s)<br />    m <span class="fu">&gt;&gt;=</span> k  <span class="fu">=</span> <span class="dt">State</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runState m s <span class="kw">of</span><br />                                 (a, s') <span class="ot">-&gt;</span> runState (k a) s'</code></pre>
<p>Jaka jest różnica?</p>
<h1 id="control.monad.state.lazy">Control.Monad.State.Lazy</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Debug.Trace</span><br /><br />f <span class="fu">=</span> \s <span class="ot">-&gt;</span><br />        <span class="kw">let</span> (x, s')  <span class="fu">=</span> doSomething s<br />            (y, s'') <span class="fu">=</span> doSomethingElse s'<br />        <span class="kw">in</span> (<span class="dv">3</span>, s'')<br /><br />doSomething s <span class="fu">=</span> trace <span class="st">&quot;doSomething&quot;</span> <span class="fu">$</span> (<span class="dv">0</span>, s)<br />doSomethingElse s <span class="fu">=</span> trace <span class="st">&quot;doSomethingElse&quot;</span> <span class="fu">$</span> (<span class="dv">3</span>, s)<br /><br />main <span class="fu">=</span> <span class="fu">print</span> (f <span class="dv">2</span>)</code></pre>
<pre><code>$ runhaskell LazyTest.hs
doSomethingElse
doSomething
(3,2)
</code></pre>
<h1 id="control.monad.state.strict">Control.Monad.State.Strict</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Debug.Trace</span><br /><br />f <span class="fu">=</span> \s <span class="ot">-&gt;</span><br />        <span class="kw">let</span> (x, s')  <span class="fu">=</span> doSomething s<br />            (y, s'') <span class="fu">=</span> doSomethingElse s'<br />        <span class="kw">in</span> (<span class="dv">3</span>, s'')<br /><br />doSomething s <span class="fu">=</span> trace <span class="st">&quot;doSomething&quot;</span> <span class="fu">$</span> (<span class="dv">0</span>, s)<br />doSomethingElse s <span class="fu">=</span> trace <span class="st">&quot;doSomethingElse&quot;</span> <span class="fu">$</span> (<span class="dv">3</span>, s)<br /><br />main <span class="fu">=</span> <span class="fu">print</span> (f <span class="dv">2</span>)</code></pre>
<pre><code>ben@sowa:~/Zajecia/Zpf/Slides/7$ runhaskell StrictTest.hs
doSomething
doSomethingElse
(3,2)
</code></pre>
<p>Zwykle kolejność obliczeń jest nam obojętna, ale np. w wypadku IO...</p>
<h1 id="czytelnik">Czytelnik</h1>
<p>Okrojona wersja stanu (stan sie nie zmienia):</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">E</span> <span class="fu">=</span> <span class="dt">Int</span>  <span class="co">-- na przyk&#322;ad</span><br /><span class="kw">type</span> <span class="dt">RM</span> a <span class="fu">=</span> <span class="dt">E</span> <span class="ot">-&gt;</span> a<br /><br /><span class="ot">rmap </span><span class="ot">::</span> (a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> <span class="dt">RM</span> a <span class="ot">-&gt;</span> <span class="dt">RM</span> b<br />rmap <span class="fu">=</span> (<span class="fu">.</span>)<br /><br /><span class="ot">rpure </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">RM</span> a<br />rpure <span class="fu">=</span> <span class="fu">const</span><br /><br /><span class="ot">rbind </span><span class="ot">::</span> <span class="dt">RM</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">RM</span> b) <span class="ot">-&gt;</span> <span class="dt">RM</span> b<br /><span class="co">-- (E -&gt; a) -&gt; (a -&gt; E -&gt; b) -&gt; E -&gt; b</span><br />rbind m k e <span class="fu">=</span> k (m e) e<br /><br /><span class="ot">rjoin </span><span class="ot">::</span> <span class="dt">RM</span> (<span class="dt">RM</span> e) <span class="ot">-&gt;</span> <span class="dt">RM</span> e<br /><span class="co">-- (E -&gt; E -&gt; a) -&gt; (E -&gt; a) </span><br />rjoin mm e <span class="fu">=</span> mm e e</code></pre>
<h1 id="monada-kontynuacji">Monada kontynuacji</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Cont</span> r a <span class="fu">=</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r<br /><span class="co">-- Zwi&#261;zek z logik&#261;:  Cont a &#8764; (a &#8594; &#8869;) &#8594; &#8869; = &#172;&#172;a</span><br /><br /><span class="ot">contra </span><span class="ot">::</span> (a<span class="ot">-&gt;</span>b) <span class="ot">-&gt;</span> (b<span class="ot">-&gt;</span>r) <span class="ot">-&gt;</span> (a<span class="ot">-&gt;</span>r)<br />contra f g <span class="fu">=</span> g <span class="fu">.</span> f<br /><br /><span class="ot">cmap </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b<br /><span class="co">--   :: (a -&gt; b) -&gt; ((a -&gt; r) -&gt; r) -&gt;  (b -&gt; r) -&gt; r</span><br />cmap f m <span class="fu">=</span> \c <span class="ot">-&gt;</span> m <span class="fu">$</span> c <span class="fu">.</span> f <span class="co">-- \c -&gt; m (contra f c)</span><br /><br /><span class="ot">cpure </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a<br />cpure <span class="fu">=</span> <span class="fu">flip</span> (<span class="fu">$</span>) <span class="co">-- \a c -&gt; c a</span><br /><br /><span class="ot">cbind </span><span class="ot">::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r b<br /><span class="co">-- ((a-&gt;r)-&gt;r)) -&gt; (a -&gt; (b-&gt;r)-&gt;r)</span><br />cbind m k <span class="fu">=</span> \c <span class="ot">-&gt;</span> m (\a <span class="ot">-&gt;</span> k a c)</code></pre>
<p>Jak zwykle w bibliotece jest to zapakowane w newtype, ale mamy funkcje</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">cont </span><span class="ot">::</span> ((a<span class="ot">-&gt;</span>r)<span class="ot">-&gt;</span>r) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a<br /><span class="ot">runCont </span><span class="ot">::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a<span class="ot">-&gt;</span>r)<span class="ot">-&gt;</span>r</code></pre>
<h1 id="kontynuacje">Kontynuacje</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">import</span> <span class="dt">Control.Monad.Cont</span><br /><br /><span class="ot">ex1 </span><span class="ot">::</span> <span class="dt">Cont</span> r <span class="dt">Int</span><br />ex1 <span class="fu">=</span> <span class="kw">do</span><br />  a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />  b <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">10</span><br />  <span class="fu">return</span> (a<span class="fu">+</span>b)<br /><br /><span class="co">-- test :: (forall r. (Show r) =&gt; Cont r Int) -&gt; String </span><br />test ex <span class="fu">=</span> runCont ex <span class="fu">show</span></code></pre>
<pre><code>&gt; test ex1
&quot;11&quot;
</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- cont :: ((a-&gt;r)-&gt;r) -&gt; Cont r a</span><br /><span class="ot">ex2 </span><span class="ot">::</span> <span class="dt">Cont</span> r <span class="dt">Int</span><br />ex2 <span class="fu">=</span> <span class="kw">do</span><br />  a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />  b <span class="ot">&lt;-</span> cont (\c <span class="ot">-&gt;</span> c <span class="dv">10</span>)<br />  <span class="fu">return</span> (a<span class="fu">+</span>b)</code></pre>
<pre><code>&gt; test ex2
&quot;11&quot;
</code></pre>
<h1 id="brak-wyniku---wyj&#261;tki">Brak wyniku - wyjątki</h1>
<pre class="sourceCode"><code class="sourceCode haskell">ex3 <span class="fu">=</span> <span class="kw">do</span><br />   a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />   b <span class="ot">&lt;-</span> cont (\c <span class="ot">-&gt;</span> <span class="st">&quot;escape&quot;</span>)<br />   <span class="fu">return</span> <span class="fu">$</span> a<span class="fu">+</span>b</code></pre>
<pre><code>&gt; test ex3
&quot;escape&quot;
</code></pre>
<p>...czyli mamy wyjątki</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">escape </span><span class="ot">::</span> r <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a<br />escape r <span class="fu">=</span> cont (<span class="fu">const</span> r)</code></pre>
<pre class="sourceCode"><code class="sourceCode haskell">ex3e <span class="fu">=</span> <span class="kw">do</span><br />   a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />   b <span class="ot">&lt;-</span> escape <span class="st">&quot;escape&quot;</span><br />   <span class="fu">return</span> <span class="fu">$</span> a<span class="fu">+</span>b</code></pre>
<h1 id="wiele-wynik&#243;w">Wiele wyników</h1>
<pre class="sourceCode"><code class="sourceCode haskell">ex4 <span class="fu">=</span> <span class="kw">do</span><br />   a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />   b <span class="ot">&lt;-</span> cont (\c <span class="ot">-&gt;</span> c <span class="dv">10</span> <span class="fu">++</span> c <span class="dv">20</span>)<br />   <span class="fu">return</span> <span class="fu">$</span> a<span class="fu">+</span>b</code></pre>
<pre><code>&gt; test ex4
&quot;1121&quot;
</code></pre>
<p>Hmm, to prawie jak monada list:</p>
<pre class="sourceCode"><code class="sourceCode haskell">test5 <span class="fu">=</span> <span class="kw">do</span> <br />  a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />  b <span class="ot">&lt;-</span> [<span class="dv">10</span>, <span class="dv">20</span>]<br />  <span class="fu">return</span> <span class="fu">$</span> a<span class="fu">+</span>b   </code></pre>
<pre><code>&gt; test5
[11,21]
</code></pre>
<h1 id="wiele-wynik&#243;w-2">Wiele wyników (2)</h1>
<pre class="sourceCode"><code class="sourceCode haskell">ex6 <span class="fu">=</span> <span class="kw">do</span><br />  a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />  b <span class="ot">&lt;-</span> <span class="dt">Cont</span> (\c <span class="ot">-&gt;</span> c <span class="dv">10</span> <span class="fu">++</span> c <span class="dv">20</span>)<br />  <span class="fu">return</span> <span class="fu">$</span> a<span class="fu">+</span>b<br /><br />test6 <span class="fu">=</span> runCont ex6 (\x <span class="ot">-&gt;</span> [x])</code></pre>
<pre><code>&gt; test6
[11,21]
</code></pre>
<p>Albo inaczej:</p>
<pre class="sourceCode"><code class="sourceCode haskell">ex7 <span class="fu">=</span> <span class="kw">do</span><br />   a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />   b <span class="ot">&lt;-</span> cont (\c <span class="ot">-&gt;</span> <span class="fu">concat</span> [c <span class="dv">10</span>, c <span class="dv">20</span>])<br />   <span class="fu">return</span> <span class="fu">$</span> a<span class="fu">+</span>b<br /><br />test7 <span class="fu">=</span> runCont ex7 (\x <span class="ot">-&gt;</span> [x])<br /><br />ex8 <span class="fu">=</span> <span class="kw">do</span><br />  a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span><br />  b <span class="ot">&lt;-</span> cont (\c <span class="ot">-&gt;</span> [<span class="dv">10</span>,<span class="dv">20</span>] <span class="fu">&gt;&gt;=</span> c)<br />  <span class="fu">return</span> <span class="fu">$</span> a<span class="fu">+</span>b<br /><br />test8 <span class="fu">=</span> runCont ex8 <span class="fu">return</span></code></pre>
<h1 id="bonus-troch&#281;-teorii-kategorii">Bonus: trochę teorii kategorii</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Category</span> (<span class="fu">~&gt;</span>) <span class="kw">where</span><br /><span class="ot">  id  </span><span class="ot">::</span> a <span class="fu">~&gt;</span> a<br /><span class="ot">  (.) </span><span class="ot">::</span> (b <span class="fu">~&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="fu">~&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="fu">~&gt;</span> c)<br /><br /><span class="kw">instance</span> <span class="dt">Category</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span><br />  <span class="fu">id</span> x <span class="fu">=</span> x<br />  (f <span class="fu">.</span> g) x <span class="fu">=</span> f (g x)<br /><br /><span class="kw">class</span> (<span class="dt">Category</span> (<span class="fu">~&gt;</span>), <span class="dt">Category</span> (<span class="fu">~~&gt;</span>)) <br />      <span class="ot">=&gt;</span> <span class="dt">Functor'</span> f (<span class="fu">~&gt;</span>) (<span class="fu">~~&gt;</span>)  <span class="fu">|</span> f (<span class="fu">~&gt;</span>) <span class="ot">-&gt;</span> (<span class="fu">~~&gt;</span>), f (<span class="fu">~~&gt;</span>) <span class="ot">-&gt;</span> (<span class="fu">~&gt;</span>)  <span class="kw">where</span><br /><span class="ot">  fmap' </span><span class="ot">::</span> (a <span class="fu">~&gt;</span> b) <span class="ot">-&gt;</span> (f a <span class="fu">~~&gt;</span> f b)<br /><br /><span class="kw">class</span> <span class="dt">Category</span> (<span class="fu">~&gt;</span>) <span class="ot">=&gt;</span> <span class="dt">Monad'</span> m (<span class="fu">~&gt;</span>) <span class="kw">where</span><br /><span class="ot">  return </span><span class="ot">::</span> a <span class="fu">~&gt;</span> m a<br /><span class="ot">  bind   </span><span class="ot">::</span> (a <span class="fu">~&gt;</span> m b) <span class="ot">-&gt;</span> (m a <span class="fu">~&gt;</span> m b)<br /><br /><span class="co">-- 1. bind return = id  </span><br /><span class="co">-- 2. bind f . return = f</span><br /><span class="co">-- 3. bind f . bind g = bind (bind g . f)</span></code></pre>
<h1 id="komonady">Komonady</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">type</span> a <span class="fu">:~&gt;</span> b <span class="fu">=</span> a <span class="ot">-&gt;</span> b<br /><br /><span class="kw">class</span> <span class="kw">Functor</span> m <span class="ot">=&gt;</span> <span class="kw">Monad</span> m <span class="kw">where</span><br /><span class="ot">  return </span><span class="ot">::</span> a <span class="fu">:~&gt;</span> m a<br /><span class="ot">  bind   </span><span class="ot">::</span> (a <span class="fu">:~&gt;</span> m b) <span class="ot">-&gt;</span> (m a <span class="fu">:~&gt;</span> m b)<br /><br /><span class="co">-- Komonada w kategorii C to monada w C^op:  </span><br /><span class="kw">class</span> <span class="kw">Functor</span> w <span class="ot">=&gt;</span> <span class="dt">Comonad</span> w <span class="kw">where</span><br /><span class="ot">  extract </span><span class="ot">::</span> w a <span class="fu">:~&gt;</span> a<br /><span class="ot">  extend </span><span class="ot">::</span> (w b <span class="fu">:~&gt;</span> a) <span class="ot">-&gt;</span> (w b <span class="fu">:~&gt;</span> w a)<br /><br /><span class="ot">(=&gt;&gt;) </span><span class="ot">::</span> <span class="dt">Comonad</span> w <span class="ot">=&gt;</span> w b <span class="ot">-&gt;</span> (w b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> w a<br />(<span class="ot">=&gt;</span><span class="fu">&gt;</span>) <span class="fu">=</span> <span class="fu">flip</span> extend</code></pre>
<h1 id="przyk&#322;ad">Przykład</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pointer</span> i e <span class="fu">=</span> <span class="dt">P</span> i (<span class="dt">Array</span> i e) <span class="kw">deriving</span> <span class="kw">Show</span><br /><br /><span class="kw">instance</span> <span class="kw">Ix</span> i <span class="ot">=&gt;</span> <span class="kw">Functor</span> (<span class="dt">Pointer</span> i) <span class="kw">where</span><br />   <span class="fu">fmap</span> f (<span class="dt">P</span> i a) <span class="fu">=</span> <span class="dt">P</span> i (<span class="fu">fmap</span> f a)<br /><br /><span class="kw">instance</span> <span class="kw">Ix</span> i <span class="ot">=&gt;</span> <span class="dt">Comonad</span> (<span class="dt">Pointer</span> i) <span class="kw">where</span><br />   extract (<span class="dt">P</span> i a) <span class="fu">=</span> a<span class="fu">!</span>i<br />   extend f (<span class="dt">P</span> i a) <span class="fu">=</span> <span class="dt">P</span> i <span class="fu">$</span> listArray bds (<span class="fu">fmap</span> (f <span class="fu">.</span> <span class="fu">flip</span> <span class="dt">P</span> a) (<span class="fu">range</span> bds))<br />       <span class="kw">where</span> bds <span class="fu">=</span> bounds a<br /><br />x <span class="fu">=</span> listArray (<span class="dv">0</span>,<span class="dv">9</span>) [<span class="dv">0</span><span class="fu">..</span><span class="dv">9</span>]<br />wrap i <span class="fu">=</span> <span class="kw">if</span> i<span class="fu">&lt;</span><span class="dv">0</span> <span class="kw">then</span> i<span class="fu">+</span><span class="dv">10</span> <span class="kw">else</span> <span class="kw">if</span> i<span class="fu">&gt;</span><span class="dv">9</span> <span class="kw">then</span> i<span class="fu">-</span><span class="dv">10</span> <span class="kw">else</span> i<br />blur (<span class="dt">P</span> i a) <span class="fu">=</span> <span class="kw">let</span><br />       k <span class="fu">=</span> wrap (i<span class="fu">-</span><span class="dv">1</span>)<br />       j <span class="fu">=</span> wrap (i<span class="fu">+</span><span class="dv">1</span>)<br />   <span class="kw">in</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">25</span><span class="fu">*</span>a<span class="fu">!</span>k <span class="fu">+</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">5</span><span class="fu">*</span>a<span class="fu">!</span>i <span class="fu">+</span> <span class="dv">0</span><span class="fu">.</span><span class="dv">25</span><span class="fu">*</span>a<span class="fu">!</span>j<br /><br />test1 <span class="fu">=</span> <span class="dt">P</span> <span class="dv">0</span> x <span class="ot">=&gt;</span><span class="fu">&gt;</span> blur<br />x <span class="fu">==&gt;</span> f <span class="fu">=</span> f x<br />test2 <span class="fu">=</span> <span class="dt">P</span> <span class="dv">0</span> x <span class="fu">==&gt;</span> <span class="fu">fmap</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="ot">=&gt;</span><span class="fu">&gt;</span> blur <span class="fu">==&gt;</span> <span class="fu">fmap</span> (<span class="fu">*</span><span class="dv">2</span>) <span class="fu">==&gt;</span> <span class="fu">fmap</span> (<span class="fu">^</span><span class="dv">2</span>)</code></pre>
<p>Ciągi operacji na poszczególnych elementach tablicy moga byc wykonywane przez osobne wątki. Komonadyczne <code>=&gt;&gt;</code> wskazuje miejsca gdzie konieczna jest synchronizacja.</p>
<h1 id="inna-prezentacja-monad-1">Inna prezentacja monad</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span><br /><span class="ot">   pure  </span><span class="ot">::</span>  a <span class="ot">-&gt;</span> f a<br /><span class="co">-- fmap  :: (a -&gt; b) -&gt; f a -&gt; f b</span><br /><span class="ot">   (&lt;*&gt;) </span><span class="ot">::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b<br /><br /><span class="co">-- fmap g . pure = pure . g</span><br /><span class="co">-- fmap g x = pure g &lt;*&gt; x</span><br /><br /><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad''</span> m <span class="kw">where</span><br /><span class="ot">  join </span><span class="ot">::</span> m (m a) <span class="ot">-&gt;</span> m a</code></pre>
<p>O Applicative jeszcze będziemy mówić.</p>
<pre class="sourceCode"><code class="sourceCode haskell"></code></pre>
</body>
</html>
