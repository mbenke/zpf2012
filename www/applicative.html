<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<h1 id="przypomnienie---funktory">Przypomnienie - Funktory</h1>
<p>Funktor to operacja <code>T :: * -&gt; *</code> na typach<br />wraz z operacją <code>fmap</code> na funkcjach</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">fmap</span><span class="ot"> </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (<span class="dt">T</span> a <span class="ot">-&gt;</span> <span class="dt">T</span> b) </code></pre>
<p>zachowującą strukturę składania funkcji, czyli</p>
<pre><code>fmap id = id
fmap (f . g) = fmap f . fmap g
</code></pre>
<h1 id="motywacja---sekwencje">Motywacja - sekwencje</h1>
<p>Przypomnijmy sobie parser dla cyfr:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">pNum </span><span class="ot">::</span> <span class="dt">Parser</span> <span class="dt">Int</span><br />pNum <span class="fu">=</span> <span class="fu">fmap</span> <span class="fu">digitToInt</span> digit</code></pre>
<p>co jest krótszym zapisem</p>
<pre class="sourceCode"><code class="sourceCode haskell">pNum <span class="fu">=</span> <span class="kw">do</span><br />     d <span class="ot">&lt;-</span> digit<br />     <span class="fu">return</span> <span class="fu">$</span> <span class="fu">digitToInt</span> d</code></pre>
<h1 id="motywacja---sekwencje-1">Motywacja - sekwencje</h1>
<p>Przypomnijmy sobie funkcję <code>sequence</code> (tu dla monady IO):</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">sequence1 </span><span class="ot">::</span> [<span class="dt">IO</span> a] <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]<br />sequence1 [] <span class="fu">=</span> <span class="fu">return</span> []<br />sequence1 (c <span class="fu">:</span> cs) <span class="fu">=</span> <span class="kw">do</span><br />  x <span class="ot">&lt;-</span> c<br />  xs <span class="ot">&lt;-</span> sequence1 cs<br />  <span class="fu">return</span> (x <span class="fu">:</span> xs)</code></pre>
<p>która &quot;wykonuje&quot; listę akcji zbierając ich wyniki w liste.</p>
<p>Możemy ją zapisac prościej uzywając &quot;monadycznej&quot; aplikacji, <code>ap</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell">sequence2 (c<span class="fu">:</span>cs) <span class="fu">=</span> <span class="fu">return</span> (<span class="fu">:</span>) <span class="ot">`ap`</span> c <span class="ot">`ap`</span> <span class="fu">sequence</span> cs<br /><br />ap mf mx <span class="fu">=</span> <span class="kw">do</span><br />  f <span class="ot">&lt;-</span> mf<br />  x <span class="ot">&lt;-</span> mx<br />  <span class="fu">return</span> <span class="fu">$</span> f x</code></pre>
<h1 id="motywacja---zipwith">Motywacja - <code>zipWith</code></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="fu">zip</span><span class="ot"> </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [(a, b)]<br /><span class="fu">zip</span> <span class="fu">=</span> <span class="fu">zipWith</span> (,)<br /><span class="fu">zipWith</span><span class="ot"> </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c]<br /><span class="fu">zipWith3</span><span class="ot"> </span><span class="ot">::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> [c] <span class="ot">-&gt;</span> [d]<br /><span class="co">-- zipWith_n :: (a1 -&gt; ... -&gt; an -&gt; b) -&gt; [a1] -&gt; ... -&gt; [an] -&gt; [b]</span><br /><span class="co">-- zipWith_n f as1 ... asn = repeat f `zap` as1 `zap` ... `zap` asn</span><br /><br /><span class="ot">zap </span><span class="ot">::</span> [a<span class="ot">-&gt;</span>b] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]<br />zap (f<span class="fu">:</span>fs) (x<span class="fu">:</span>xs) <span class="fu">=</span> f x<span class="fu">:</span>zap fs xs<br />zap _ _ <span class="fu">=</span> []<br /><br /><span class="ot">transpose </span><span class="ot">::</span> [[a]] <span class="ot">-&gt;</span> [[a]]<br />transpose [] <span class="fu">=</span> <span class="fu">repeat</span> []<br />transpose (xs<span class="fu">:</span>xss) <span class="fu">=</span> <span class="fu">repeat</span> (<span class="fu">:</span>) <span class="ot">`zap`</span> xs <span class="ot">`zap`</span> transpose xss<br /><span class="co">-- zipWith (:) xs (transpose xss)</span></code></pre>
<h1 id="motywacja---interpreter">Motywacja - interpreter</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exp</span> v <span class="fu">=</span> <span class="dt">Var</span> v<br />           <span class="fu">|</span> <span class="dt">Val</span> <span class="dt">Int</span><br />           <span class="fu">|</span> <span class="dt">Add</span> (<span class="dt">Exp</span> v) (<span class="dt">Exp</span> v)<br /><br /><span class="ot">eval1 </span><span class="ot">::</span> <span class="dt">Exp</span> v <span class="ot">-&gt;</span> <span class="dt">Env</span> v <span class="ot">-&gt;</span> <span class="dt">Int</span><br />eval1 (<span class="dt">Var</span> x) env <span class="fu">=</span> fetch x env<br />eval1 (<span class="dt">Val</span> i) env <span class="fu">=</span> i<br />eval1 (<span class="dt">Add</span> p q) env <span class="fu">=</span> eval1 p env <span class="fu">+</span> eval1 q env<br /><br />eval2 (<span class="dt">Var</span> x) <span class="fu">=</span> fetch x<br />eval2 (<span class="dt">Val</span> i) <span class="fu">=</span> k i<br />eval2 (<span class="dt">Add</span> p q) <span class="fu">=</span> k (<span class="fu">+</span>) <span class="ot">`s`</span> eval2 p <span class="ot">`s`</span> eval2 q<br /><br />k x y <span class="fu">=</span> x<br /><span class="ot">s </span><span class="ot">::</span> (env <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (env <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (env <span class="ot">-&gt;</span> b)<br />s ef es env <span class="fu">=</span> (ef env) (es env)</code></pre>
<h1 id="klasa-applicative">Klasa Applicative</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Control.Applicative</span><br /><span class="kw">class</span> (<span class="kw">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>  <br /><span class="ot">    pure </span><span class="ot">::</span> a <span class="ot">-&gt;</span> f a  <br /><span class="ot">    (&lt;*&gt;) </span><span class="ot">::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b  </code></pre>
<p>Przykład:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span><br />  pure <span class="fu">=</span> <span class="kw">Just</span><br />  (<span class="kw">Just</span> f) <span class="fu">&lt;*&gt;</span> (<span class="kw">Just</span> x) <span class="fu">=</span> <span class="kw">Just</span> (f x)<br />  _        <span class="fu">&lt;*&gt;</span> _ <span class="fu">=</span> <span class="kw">Nothing</span><br /><br /><span class="co">-- &gt;&gt;&gt; fmap (+1) (Just 5)</span><br /><span class="co">-- Just 6</span><br /><span class="co">-- &gt;&gt;&gt; pure (+1) &lt;*&gt; Just 5</span><br /><span class="co">-- Just 6</span><br /><span class="co">-- &gt;&gt;&gt; pure (+) &lt;*&gt; Just 2 &lt;*&gt; Just 2</span><br /><span class="co">-- Just 4</span></code></pre>
<h1 id="prawa">Prawa</h1>
<pre><code>fmap g x = pure g &lt;*&gt; x
pure id &lt;*&gt; u = u (konsekwencja powyższego i praw fmap)
pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w =  u &lt;*&gt; v &lt;*&gt; w
pure f &lt;*&gt; pure x = pure (f x)
u &lt;*&gt; pure x = pure (\f -&gt; f x) &lt;*&gt; u
</code></pre>
<p>W stylu aplikatywnym fmap zapisujemy jako <code>&lt;$&gt;</code>:</p>
<pre class="sourceCode"><code class="sourceCode haskell">f <span class="fu">&lt;$&gt;</span> u <span class="fu">=</span> pure f <span class="fu">&lt;*&gt;</span> u</code></pre>
<p><strong>Ćwiczenie:</strong> sprawdź, że powyższe prawa zachodzą dla podanej instancji dla <code>Maybe</code>.</p>
<h1 id="przyk&#322;ady-idiomatycznie">Przykłady idiomatycznie</h1>
<pre class="sourceCode"><code class="sourceCode haskell">sequence3 (c<span class="fu">:</span>cs) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> c <span class="fu">&lt;*&gt;</span> <span class="fu">sequence</span> cs<br /><br /><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span><br />  pure <span class="fu">=</span> <span class="fu">repeat</span><br />  (f <span class="fu">:</span> fs) <span class="fu">&lt;*&gt;</span> (x <span class="fu">:</span> xs) <span class="fu">=</span> f x <span class="fu">:</span> (fs <span class="fu">&lt;*&gt;</span> xs)<br />  _        <span class="fu">&lt;*&gt;</span> _        <span class="fu">=</span> []<br /><br /><span class="ot">transpose2 </span><span class="ot">::</span> [[a]] <span class="ot">-&gt;</span> [[a]]<br />transpose2 [] <span class="fu">=</span> pure []<br />transpose2 (xs <span class="fu">:</span>xss) <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> xs <span class="fu">&lt;*&gt;</span> transpose2 xss<br /><br /><span class="kw">instance</span> <span class="dt">Applicative</span> ((<span class="ot">-&gt;</span>) env) <span class="kw">where</span><br />  pure <span class="fu">=</span> <span class="fu">const</span><br />  ef <span class="fu">&lt;*&gt;</span> es <span class="fu">=</span> \env <span class="ot">-&gt;</span> (ef env) (es env)<br /><br />eval3 (<span class="dt">Var</span> x) <span class="fu">=</span> fetch x<br />eval3 (<span class="dt">Val</span> i) <span class="fu">=</span> pure i<br />eval3 (<span class="dt">Add</span> p q) <span class="fu">=</span> pure (<span class="fu">+</span>) <span class="fu">&lt;*&gt;</span> eval3 p <span class="fu">&lt;*&gt;</span> eval3 q</code></pre>
<h1 id="nawiasy-idiomatyczne-idiom-brackets">Nawiasy idiomatyczne (idiom brackets)</h1>
<p>Conor McBride zaproponował specjalną notację idiomatyczną:</p>
<pre><code> (|f a1 .. an|) = pure f &lt;*&gt; a1 &lt;*&gt; .. &lt;*&gt; an
sequence4 (c:cs) = (| (:) c (sequence cs) |)
eval4  (Add p q) = (| (+) (eval3 p) (eval3 q) |)
</code></pre>
<p>nie weszła ona do standardu Haskella, choć jest dostępna w SHE.</p>
<p>https://personal.cis.strath.ac.uk/~conor/pub/she/</p>
<h1 id="nawiasy-idiomatyczne-idiom-brackets-1">Nawiasy idiomatyczne (idiom brackets)</h1>
<p>Przy pomocy klas możemy udostępnić podobną, choć brzydszą notację:</p>
<pre class="sourceCode"><code class="sourceCode haskell">sequence4 (c<span class="fu">:</span>cs) <span class="fu">=</span> iI (<span class="fu">:</span>) c (<span class="fu">sequence</span> cs) <span class="dt">Ii</span><br />eval4  (<span class="dt">Add</span> p q) <span class="fu">=</span> iI (<span class="fu">+</span>) (eval3 p) (eval3 q) <span class="dt">Ii</span><br /><br /><span class="kw">class</span> <span class="dt">Applicative</span> i <span class="ot">=&gt;</span> <span class="dt">Idiomatic</span> i f g <span class="fu">|</span> g <span class="ot">-&gt;</span> f i <span class="kw">where</span><br /><span class="ot">   idiomatic </span><span class="ot">::</span> i f <span class="ot">-&gt;</span> g<br /><br /><span class="ot">iI </span><span class="ot">::</span> <span class="dt">Idiomatic</span> i f g <span class="ot">=&gt;</span> f <span class="ot">-&gt;</span> g<br />iI <span class="fu">=</span> idiomatic <span class="fu">.</span> pure<br /><br /><span class="kw">data</span> <span class="dt">Ii</span>  <span class="fu">=</span>  <span class="dt">Ii</span><br /><br /><span class="kw">instance</span> <span class="dt">Applicative</span> i    <span class="ot">=&gt;</span> <span class="dt">Idiomatic</span> i x (<span class="dt">Ii</span> <span class="ot">-&gt;</span> i x) <span class="kw">where</span><br />  idiomatic xi <span class="dt">Ii</span>     <span class="fu">=</span> xi<br /><br /><span class="kw">instance</span> <span class="dt">Idiomatic</span> i f g  <span class="ot">=&gt;</span> <span class="dt">Idiomatic</span> i (s <span class="ot">-&gt;</span> f) (i s <span class="ot">-&gt;</span> g) <span class="kw">where</span><br />  idiomatic sfi si    <span class="fu">=</span> idiomatic (sfi <span class="fu">&lt;*&gt;</span> si)</code></pre>
<h1 id="idiomy-a-monady">Idiomy a monady</h1>
<p>Każda monada jest funktorem aplikatywnym, np.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span><br />  pure <span class="fu">=</span> <span class="fu">return</span><br />  (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap<br /><br />ap mf mx <span class="fu">=</span> mf <span class="fu">&gt;&gt;=</span> \f <span class="ot">-&gt;</span> m x <span class="fu">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> <span class="fu">return</span> (f x)</code></pre>
<p>Natomiast w ogólności nie na odwrót, np. nasza instancja dla list</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span><br />  pure <span class="fu">=</span> <span class="fu">repeat</span><br />  (f <span class="fu">:</span> fs) <span class="fu">&lt;*&gt;</span> (x <span class="fu">:</span> xs) <span class="fu">=</span> f x <span class="fu">:</span> (fs <span class="fu">&lt;*&gt;</span> xs)<br />  _        <span class="fu">&lt;*&gt;</span> _        <span class="fu">=</span> []</code></pre>
<p>czy da się zdefiniować <code>&gt;&gt;=</code> tak by <code>ap</code> odpowiadało <code>&lt;*&gt;</code> ?</p>
<p><em>Ćwiczenie:</em> sprawdź, że prawa dla idiomów wynikają z praw dla monad.</p>
<h1 id="idiomy-a-monady-1">Idiomy a monady</h1>
<p>Strukturze monadycznej dla list odpowiada inna instancja Applicative dla list, gdzie listę funkcji aplikujemy do listy argumentów metodą &quot;każdy z każdym&quot;:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> [] <span class="kw">where</span><br />  pure <span class="fu">=</span> (<span class="fu">:</span>[])<br />  fs <span class="fu">&lt;*&gt;</span> xs <span class="fu">=</span> <span class="fu">concat</span> <span class="fu">$</span> for fs (for xs)<br /><br />for <span class="fu">=</span> <span class="fu">flip</span> <span class="fu">map</span></code></pre>
<p><strong>Ćwiczenie:</strong> wykaż poprawność powyższej definicji</p>
<p><strong>Ćwiczenie:</strong> napisz dwie instancje Applicative dla State.</p>
<h1 id="idiomy-a-monady-2">Idiomy a monady</h1>
<p>W ogólności sekwencjonowanie monadyczne jest silniejsze od idiomatycznego:</p>
<pre class="sourceCode"><code class="sourceCode haskell">mif c t e <span class="fu">=</span> <span class="kw">do</span> { b <span class="ot">&lt;-</span> c; <span class="kw">if</span> b <span class="kw">then</span> t <span class="kw">else</span> e }<br /><br />aif fc ft fe <span class="fu">=</span> cond <span class="fu">&lt;$&gt;</span> fc <span class="fu">&lt;*&gt;</span> ft <span class="fu">&lt;*&gt;</span> fe <span class="kw">where</span><br />  cond c t e <span class="fu">=</span><span class="kw">if</span> c <span class="kw">then</span> t <span class="kw">else</span> e<br /><br />main <span class="fu">=</span> <span class="kw">do</span><br />  <span class="fu">putStrLn</span> <span class="st">&quot;Monad:&quot;</span><br />  mif (<span class="fu">return</span> <span class="kw">True</span>) (<span class="fu">putStrLn</span> <span class="st">&quot;True&quot;</span>) (<span class="fu">putStrLn</span> <span class="st">&quot;False&quot;</span>)<br />  <span class="fu">putStrLn</span> <span class="st">&quot;Idiom:&quot;</span><br />  aif (pure <span class="kw">True</span>) (<span class="fu">putStrLn</span> <span class="st">&quot;True&quot;</span>) (<span class="fu">putStrLn</span> <span class="st">&quot;False&quot;</span>)</code></pre>
<pre><code>Monad:
True
Idiom:
True
False
</code></pre>
<h1 id="monoid">Monoid</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Data.Monoid</span><br /><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span><br /><span class="ot">  mempty </span><span class="ot">::</span> a<br /><span class="ot">  mappend </span><span class="ot">::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a<br /><span class="ot">  mconcat </span><span class="ot">::</span> [a] <span class="ot">-&gt;</span> a<br />  mconcat <span class="fu">=</span> <span class="fu">foldr</span> mappend mempty</code></pre>
<p>Monoid, aplikatywnie:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- typ fantomowy: nie u&#380;ywa swojego argumentu</span><br /><span class="kw">newtype</span> <span class="dt">Accy</span> o a <span class="fu">=</span> <span class="dt">Acc</span>{<span class="ot">acc</span><span class="ot">::</span>o}<br /><br /><span class="kw">instance</span> <span class="dt">Monoid</span> o <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Accy</span> o) <span class="kw">where</span><br />  pure _ <span class="fu">=</span> <span class="dt">Acc</span> mempty<br />  <span class="dt">Acc</span> o1 <span class="fu">&lt;*&gt;</span> <span class="dt">Acc</span> o2 <span class="fu">=</span> <span class="dt">Acc</span> (o1 <span class="ot">`mappend`</span> o2)</code></pre>
<p>nie jest monadyczne, bo jak zdefiniować</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) </span><span class="ot">::</span> <span class="dt">Accy</span> o a <span class="ot">-&gt;</span> (a<span class="ot">-&gt;</span><span class="dt">Accy</span> o b) <span class="ot">-&gt;</span> <span class="dt">Accy</span> o b</code></pre>
<h1 id="akumulowanie-b&#322;&#281;d&#243;w">Akumulowanie błędów</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Except</span> err a <span class="fu">=</span> <span class="dt">Ok</span> a <span class="fu">|</span> <span class="dt">Failed</span> err<br /><br /><span class="kw">instance</span> <span class="dt">Monoid</span> err <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Except</span> err) <span class="kw">where</span><br />  pure <span class="fu">=</span> <span class="dt">Ok</span><br />  <span class="dt">Ok</span> f <span class="fu">&lt;*&gt;</span> <span class="dt">Ok</span> x <span class="fu">=</span> <span class="dt">Ok</span> (f x)<br />  <span class="dt">Ok</span> _ <span class="fu">&lt;*&gt;</span> <span class="dt">Failed</span> err <span class="fu">=</span> <span class="dt">Failed</span> err<br />  <span class="dt">Failed</span> err <span class="fu">&lt;*&gt;</span> <span class="dt">Ok</span> _ <span class="fu">=</span> <span class="dt">Failed</span> err<br />  <span class="dt">Failed</span> e1 <span class="fu">&lt;*&gt;</span> <span class="dt">Failed</span> e2 <span class="fu">=</span> <span class="dt">Failed</span> (e1 <span class="ot">`mappend`</span> e2)</code></pre>
<p>trudno zrobić analog monadyczny</p>
<h1 id="sk&#322;adanie-idiom&#243;w">Składanie idiomów</h1>
<p>Składanie monad jest trudne (i nie zawsze możliwe).</p>
<p>Składanie idiomów jest łatwe</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> (g <span class="fu">:.</span> f) a <span class="fu">=</span> <span class="dt">O</span> {<span class="ot"> unO </span><span class="ot">::</span> (g (f a)) }<br /><br /><span class="kw">instance</span> (<span class="dt">Applicative</span> g, <span class="dt">Applicative</span> f) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (g <span class="fu">:.</span> f) <span class="kw">where</span><br />  pure  <span class="fu">=</span> <span class="dt">O</span> <span class="fu">.</span> pure <span class="fu">.</span> pure<br />  <span class="dt">O</span> gs <span class="fu">&lt;*&gt;</span> <span class="dt">O</span> xs <span class="fu">=</span> <span class="co">-- O (| (&lt;*&gt;) gs xs |) </span><br />                  <span class="dt">O</span> ( (<span class="fu">&lt;*&gt;</span>) <span class="fu">&lt;$&gt;</span> gs <span class="fu">&lt;*&gt;</span> xs)</code></pre>
<p><strong>Ćwiczenie:</strong> zdefiniować</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="kw">Functor</span> g, <span class="kw">Functor</span> f) <span class="ot">=&gt;</span> <span class="kw">Functor</span> (g <span class="fu">:.</span> f) <span class="kw">where</span> <span class="fu">...</span></code></pre>
<p>i sprawdzić, że złożenie funktorów aplikatywnych spełnia prawa dla funktora aplikatywnego.</p>
<h1 id="kategoryjnie-strong-lax-monoidal-functor">Kategoryjnie: strong lax monoidal functor</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monoidal</span> f <span class="kw">where</span>                  <br /><span class="ot">  unit </span><span class="ot">::</span> f ()<br /><span class="ot">  pair </span><span class="ot">::</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (a,b)<br /><br /><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monoidal</span> f <span class="kw">where</span><br />  unit <span class="fu">=</span> pure ()<br />  pair fa fb <span class="fu">=</span> (,) <span class="fu">&lt;$&gt;</span> fa <span class="fu">&lt;*&gt;</span> fb<br /><br /><span class="kw">instance</span> <span class="dt">Monoidal</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>  <br />  pure x <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">const</span> x) unit<br />  mf <span class="fu">&lt;*&gt;</span> mx <span class="fu">=</span> <span class="fu">fmap</span> (<span class="fu">$</span>) (pair mf mx)</code></pre>
<p>Żeby uzyskać prawdziwą równoważność trzeba oczywiście mieć pewne prawa dla Monoidal. Okazuje się, że jest to coś, co w teori kategorii nazywa się <em>strong lax monoidal functor</em> ;-)</p>
<h1 id="parsery">Parsery</h1>
<p>Zauważmy natomiast, że <code>Monoidal</code> jest naturalną strukturą dla parserów</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monoidal</span> f <span class="kw">where</span>                  <br /><span class="ot">  unit </span><span class="ot">::</span> f ()<br /><span class="ot">  pair </span><span class="ot">::</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (a,b)<br /><br /><span class="ot">emptyP </span><span class="ot">::</span> <span class="dt">Parser</span> ()<br /><span class="ot">thenP </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a,b)</code></pre>
<p>tyle, że typy robią się skomplikowane, dlatego łatwiej używać <code>Applicative</code></p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- S   -&gt;  ( S ) S | epsilon</span><br />parens <span class="fu">=</span> (\_ s _ s2 <span class="ot">-&gt;</span> <span class="fu">max</span> (<span class="dv">1</span><span class="fu">+</span>s) s2) <span class="fu">&lt;$&gt;</span> <br />         char <span class="ch">'('</span> <span class="fu">&lt;*&gt;</span> parens <span class="fu">&lt;*&gt;</span> char <span class="ch">')'</span> <span class="fu">&lt;*&gt;</span> parens <br />         <span class="fu">&lt;|&gt;</span> pure <span class="dv">0</span></code></pre>
<h1 id="alternative">Alternative</h1>
<p>Potrzebujemy jeszcze tylko alternatywy:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span><br /><span class="ot">  empty </span><span class="ot">::</span> f a<br /><span class="ot">  (&lt;|&gt;) </span><span class="ot">::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</code></pre>
<p>spełniającej aksjomaty monoidu. Patrz też MonadPlus:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">class</span> <span class="kw">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadPlus</span> m <span class="kw">where</span><br /><span class="ot">  mzero </span><span class="ot">::</span> m a<br /><span class="ot">  mplus </span><span class="ot">::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a<br /><br /><span class="co">-- mzero &gt;&gt;= f  =  mzero</span><br /><span class="co">-- v &gt;&gt; mzero   =  mzero</span></code></pre>
<h1 id="koniec">Koniec</h1>
<pre class="sourceCode"><code class="sourceCode haskell"></code></pre>
</body>
</html>
