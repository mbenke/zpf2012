<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<h1 id="kombinatory-parsuj&#261;ce">Kombinatory parsujące</h1>
<p>Kod w katalogu Code/Parse1</p>
<p>Możemy zdefiniować typ parserów na przykład jako</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> {<span class="ot"> runParser </span><span class="ot">::</span> <br />                       <span class="dt">String</span> <span class="ot">-&gt;</span> [(a,<span class="dt">String</span>)] }</code></pre>
<p>albo, używając transformatorów monad</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">StateT</span> [<span class="dt">Char</span>] (<span class="dt">ErrorT</span> <span class="dt">String</span> []) a</code></pre>
<p>oraz kombinatory (funkcje) reprezentujące elementarne parsery i~sposoby łączenia parserów:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">item </span><span class="ot">::</span> <span class="dt">Parser</span> <span class="dt">Char</span><br /><span class="ot">eof </span><span class="ot">::</span> <span class="dt">Parser</span> ()<br /><span class="ot">(&lt;|&gt;) </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a<br /><span class="ot">satisfy </span><span class="ot">::</span> (<span class="dt">Char</span><span class="ot">-&gt;</span><span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span><br /><span class="ot">char </span><span class="ot">::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span><br />char x <span class="fu">=</span> satisfy (<span class="fu">==</span>x)<br />many,<span class="ot"> many1 </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]\</code></pre>
<h1 id="parsec">Parsec</h1>
<p>Przeanalizujmy teraz jak zbudowana jest biblioteka Parsec, najpierw w wersji 2, potem 3</p>
<p>Wersja 2 oparta jest na monadzie stanu, w pierwszym przybliżeniu:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Code/Parse1/MyParsec2a</span><br /><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> {<span class="ot"> runParser </span><span class="ot">::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Reply</span> a }<br /><span class="co">-- Poni&#380;sze typy b&#281;d&#261; rozszerzane w kolejnych wersjach</span><br /><span class="kw">type</span> <span class="dt">State</span> <span class="fu">=</span> [<span class="dt">Char</span>]<br /><span class="kw">data</span> <span class="dt">Reply</span> a <span class="fu">=</span> <span class="dt">Ok</span> a <span class="dt">State</span> <span class="fu">|</span> <span class="dt">Error</span> <span class="dt">ParseError</span>  <br /><span class="kw">type</span> <span class="dt">ParseError</span> <span class="fu">=</span> <span class="dt">String</span></code></pre>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">p3 </span><span class="ot">::</span> <span class="dt">Parser</span> <span class="dt">String</span><br />p3 <span class="fu">=</span> p <span class="fu">&lt;|&gt;</span> q <span class="kw">where</span><br />  p <span class="fu">=</span> char <span class="ch">'p'</span> <span class="fu">&gt;&gt;</span> eof <span class="fu">&gt;&gt;</span> <span class="fu">return</span> <span class="st">&quot;p&quot;</span><br />  q <span class="fu">=</span> char <span class="ch">'p'</span> <span class="fu">&gt;&gt;</span> char <span class="ch">'q'</span> <span class="fu">&gt;&gt;</span> eof <span class="fu">&gt;&gt;</span> <span class="fu">return</span> <span class="st">&quot;q&quot;</span><br />test3 <span class="fu">=</span> runParser p3 <span class="st">&quot;pq&quot;</span><br /><br /><span class="fu">*</span><span class="dt">MyParsec2a.Prim</span><span class="fu">&gt;</span> test3<br /><span class="dt">Ok</span> <span class="st">&quot;q&quot;</span> <span class="st">&quot;&quot;</span></code></pre>
<h1 id="podstawowe-kombinatory">Podstawowe kombinatory</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">item </span><span class="ot">::</span> <span class="dt">Parser</span> <span class="dt">Char</span><br />item <span class="fu">=</span> <span class="dt">Parser</span> item0 <span class="kw">where</span><br /><span class="ot">  item0 </span><span class="ot">::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Reply</span> <span class="dt">Char</span><br />  item0 [] <span class="fu">=</span> <span class="dt">Error</span> <span class="fu">$</span> unexpected <span class="st">&quot;EOF&quot;</span><br />  item0 (x<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dt">Ok</span> x xs<br /><br /><span class="ot">eof </span><span class="ot">::</span> <span class="dt">Parser</span> ()<br />eof <span class="fu">=</span> <span class="dt">Parser</span> eof' <span class="kw">where</span><br />  eof' [] <span class="fu">=</span> <span class="dt">Ok</span> () []<br />  eof' _ <span class="fu">=</span> <span class="dt">Error</span> (expected <span class="st">&quot;EOF&quot;</span>)<br /><br /><span class="ot">char </span><span class="ot">::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span><br />char c <span class="fu">=</span> (satisfy (<span class="fu">==</span>c)) <br /><br /><span class="ot">satisfy </span><span class="ot">::</span> (<span class="dt">Char</span><span class="ot">-&gt;</span><span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span><br />satisfy p <span class="fu">=</span> <span class="dt">Parser</span> sat' <span class="kw">where</span> <br />  sat' []    <span class="fu">=</span> <span class="dt">Error</span> (expected <span class="st">&quot;EOF&quot;</span>) <span class="co">-- or check (p EOF)</span><br />  sat' (a<span class="fu">:</span>s) <span class="fu">=</span> <span class="kw">if</span> (p a) <span class="kw">then</span> <span class="dt">Ok</span> a s <span class="kw">else</span> <span class="dt">Error</span> (unexpected <span class="fu">$</span> <span class="fu">show</span> a) </code></pre>
<h1 id="sekwencjonowanie-monada">Sekwencjonowanie: monada</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span><br />  <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="dt">Ok</span> a s<br /><br />  m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Parser</span> (bind m k) <span class="kw">where</span> <br />    bind (<span class="dt">Parser</span> f) k s <span class="fu">=</span> <span class="kw">case</span> f s <span class="kw">of</span><br />      <span class="dt">Ok</span> a s' <span class="ot">-&gt;</span> runParser (k a) s'<br />      <span class="dt">Error</span> e <span class="ot">-&gt;</span> <span class="dt">Error</span> e<br /><br />p0 <span class="fu">=</span> <span class="fu">return</span> ()<br />test0 <span class="fu">=</span> testP p0 <span class="st">&quot;&quot;</span><br /><br />p2 <span class="fu">=</span> item <span class="fu">&gt;&gt;</span> item<br />test1 <span class="fu">=</span> testP p2 <span class="st">&quot;&quot;</span> <span class="co">-- expect &quot;EOF&quot;</span><br />test2 <span class="fu">=</span> testP p2 <span class="st">&quot;abc&quot;</span> <span class="co">-- &quot;'b', c&quot;</span></code></pre>
<h1 id="zero-i-plus">Zero i Plus</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">parserZero </span><span class="ot">::</span> <span class="dt">Parser</span> a<br />parserZero <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="dt">Error</span> unknownError<br /><br /><span class="ot">parserPlus </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a<br />parserPlus p q <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p s <span class="kw">of</span><br />  <span class="dt">Error</span> e <span class="ot">-&gt;</span> runParser q s<br />  ok <span class="ot">-&gt;</span> ok<br /><br />(<span class="fu">&lt;|&gt;</span>) <span class="fu">=</span> parserPlus  <br /><br /><span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Parser</span> <span class="kw">where</span><br />  mzero <span class="fu">=</span> parserZero<br />  mplus <span class="fu">=</span> parserPlus</code></pre>
<h1 id="ci&#261;gi">Ciągi</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">space </span><span class="ot">::</span> <span class="dt">Parser</span> <span class="dt">Char</span><br />space <span class="fu">=</span> satisfy <span class="fu">isSpace</span><br /><br />many,<span class="ot"> many1 </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]<br />many p  <span class="fu">=</span> many1 p <span class="fu">&lt;|&gt;</span> <span class="fu">return</span> []<br />many1 p <span class="fu">=</span> <span class="kw">do</span> { x <span class="ot">&lt;-</span> p ; xs <span class="ot">&lt;-</span> many p; <span class="fu">return</span> (x<span class="fu">:</span>xs) }<br /><br /><span class="ot">skipMany </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()<br />skipMany p <span class="fu">=</span> many p <span class="fu">&gt;&gt;</span> <span class="fu">return</span> ()  <span class="co">-- mo&#380;na efektywniej</span><br />spaces p <span class="fu">=</span> skipMany space</code></pre>
<h1 id="przyk&#322;ad">Przykład</h1>
<p>Za &quot;Real World Haskell&quot;: http://book.realworldhaskell.org/read/using-parsec.html</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">csvFile </span><span class="ot">::</span> <span class="dt">Parser</span> [[<span class="dt">String</span>]]<br />csvFile <span class="fu">=</span> <br />    <span class="kw">do</span> result <span class="ot">&lt;-</span> many line<br />       eof<br />       <span class="fu">return</span> result</code></pre>
<p>Ale można lepiej:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">endBy  </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> a<br />endBy p q <span class="fu">=</span> <span class="kw">do</span> {x <span class="ot">&lt;-</span> p; q; <span class="fu">return</span> x}<br /><br /><span class="ot">manyTill </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> b <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]<br />manyTill p end  <span class="fu">=</span> scan <span class="kw">where</span><br />  scan <span class="fu">=</span> <span class="kw">do</span>{ end; <span class="fu">return</span> [] }<br />      <span class="fu">&lt;|&gt;</span><br />         <span class="kw">do</span>{ x <span class="ot">&lt;-</span> p; xs <span class="ot">&lt;-</span> scan; <span class="fu">return</span> (x<span class="fu">:</span>xs) }<br /><br />csvFile <span class="fu">=</span> manyTill eof line<br />line <span class="fu">=</span> cells <span class="ot">`endBy`</span> eol</code></pre>
<h1 id="jeszcze-ci&#261;gi">Jeszcze ciągi</h1>
<p>Linia pliku CSV to ciąg komórek rozdzielonych przecinkami</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">cells </span><span class="ot">::</span> <span class="dt">Parser</span> [<span class="dt">String</span>]<br />cells <span class="fu">=</span> <br />    <span class="kw">do</span> first <span class="ot">&lt;-</span> cellContent<br />       next <span class="ot">&lt;-</span> remainingCells<br />       <span class="fu">return</span> (first <span class="fu">:</span> next)<br /><br /><span class="ot">remainingCells </span><span class="ot">::</span> <span class="dt">Parser</span> [<span class="dt">String</span>]<br />remainingCells <span class="fu">=</span><br />    (char <span class="ch">','</span> <span class="fu">&gt;&gt;</span> cells)<br />    <span class="fu">&lt;|&gt;</span> (<span class="fu">return</span> [])    </code></pre>
<p>...ale chcielibyśmy prościej:</p>
<pre class="sourceCode"><code class="sourceCode haskell">cells <span class="fu">=</span> cellContent <span class="ot">`sepBy`</span> char <span class="ch">','</span><br /><br />sepBy p sep         <span class="fu">=</span> sepBy1 p sep <span class="fu">&lt;|&gt;</span> <span class="fu">return</span> []<br />sepBy1 p sep        <span class="fu">=</span> <span class="kw">do</span>{ x <span class="ot">&lt;-</span> p<br />                        ; xs <span class="ot">&lt;-</span> many (sep <span class="fu">&gt;&gt;</span> p)<br />                        ; <span class="fu">return</span> (x<span class="fu">:</span>xs)<br />                        }</code></pre>
<h1 id="ci&#261;gi-ze-znacz&#261;cymi-separatorami">Ciągi ze znaczącymi separatorami</h1>
<p>Klasyczny przykład - wyrażenia arytmetyczne</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- &gt;  expr    = term   `chainl1` addop</span><br /><span class="co">-- &gt;  term    = factor `chainl1` mulop</span><br /><span class="co">-- &gt;  factor  = parens expr &lt;|&gt; integer</span><br /><span class="co">-- &gt;</span><br /><span class="co">-- &gt;  mulop   =   do{ symbol &quot;*&quot;; return (*)   }</span><br /><span class="co">-- &gt;          &lt;|&gt; do{ symbol &quot;/&quot;; return (div) }</span><br /><span class="co">-- &gt;</span><br /><span class="co">-- &gt;  addop   =   do{ symbol &quot;+&quot;; return (+) }</span><br /><span class="co">-- &gt;          &lt;|&gt; do{ symbol &quot;-&quot;; return (-) }</span><br /><br /><span class="ot">chainl1 </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (a<span class="ot">-&gt;</span>a<span class="ot">-&gt;</span>a) <span class="ot">-&gt;</span> <span class="dt">Parser</span> a<br />chainl1 p op        <span class="fu">=</span> <span class="kw">do</span>{ x <span class="ot">&lt;-</span> p; rest x }<br />                    <span class="kw">where</span><br />                      rest x    <span class="fu">=</span> <span class="kw">do</span>{ f <span class="ot">&lt;-</span> op<br />                                    ; y <span class="ot">&lt;-</span> p<br />                                    ; rest (f x y)<br />                                    }<br />                                <span class="fu">&lt;|&gt;</span> <span class="fu">return</span> x</code></pre>
<h1 id="lepsza-obs&#322;uga-b&#322;&#281;d&#243;w">Lepsza obsługa błędów</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">p4 </span><span class="ot">::</span> <span class="dt">Parser</span> <span class="dt">Int</span><br />p4 <span class="fu">=</span> <span class="fu">fmap</span> <span class="fu">digitToInt</span> (digit)<br />test4a <span class="fu">=</span> testP p4 <span class="st">&quot;7&quot;</span><br />test4b <span class="fu">=</span> testP p4 <span class="st">&quot;x&quot;</span><br /><br /><span class="co">-- &gt;&gt;&gt; test4a</span><br /><span class="co">-- Ok 7 &quot;&quot;</span><br /><span class="co">-- &gt;&gt;&gt; test4b</span><br /><span class="co">-- Error &quot;unexpected 'x'&quot;</span></code></pre>
<p>Chcielibyśmy, by komunikat o błędzie podawał:</p>
<ul>
<li>gdzie wystąpił błąd</li>
<li>czego oczekiwano...</li>
</ul>
<p>Dla zrealizowania pierwszego postulatu, stan musi przechowywać bieżącą pozycję, np.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">State</span> <span class="fu">=</span> <span class="dt">State</span> {<span class="ot">stPos </span><span class="ot">::</span> <span class="dt">Pos</span>,<span class="ot"> stInput </span><span class="ot">::</span> <span class="dt">String</span>}</code></pre>
<ul>
<li>Ćwiczenie: zmodyfikuj MyParsec2a tak, aby przechowywał i raportował pozycje błędów.</li>
</ul>
<h1 id="lepsze-raportowanie-b&#322;&#281;d&#243;w">Lepsze raportowanie błędów</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="ot">digit </span><span class="ot">::</span> <span class="dt">Parser</span> <span class="dt">Char</span><br />digit <span class="fu">=</span> satisfy <span class="fu">isDigit</span> <span class="fu">&lt;?&gt;</span> <span class="st">&quot;digit&quot;</span><br /><br /><span class="co">-- *MyParsec2b&gt; test4b</span><br /><span class="co">-- Error (Expected [&quot;digit&quot;])</span></code></pre>
<h1 id="lepsze-raportowanie-b&#322;&#281;d&#243;w-1">Lepsze raportowanie błędów</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">ParseError</span> <span class="fu">=</span> <span class="dt">Message</span> <span class="co">-- lepiej [Message]</span><br /><br /><span class="kw">data</span> <span class="dt">Message</span> <span class="fu">=</span> <br />  <span class="dt">UnknownError</span> <span class="dt">String</span><br />  <span class="fu">|</span> <span class="dt">Unexpected</span> <span class="dt">String</span><br />  <span class="fu">|</span> <span class="dt">Expected</span> [<span class="dt">String</span>]<br />               <span class="kw">deriving</span> <span class="kw">Show</span><br /><br />p <span class="fu">&lt;?&gt;</span> expected <span class="fu">=</span> label p expected<br /><br />label p expected <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \st <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p st <span class="kw">of</span><br />  <span class="dt">Ok</span> a st' <span class="ot">-&gt;</span> <span class="dt">Ok</span> a st'<br />  <span class="dt">Error</span> e <span class="ot">-&gt;</span> <span class="dt">Error</span> <span class="fu">$</span> addExpected expected e<br /><br />addExpected x (<span class="dt">Expected</span> xs) <span class="fu">=</span> <span class="dt">Expected</span> (x<span class="fu">:</span>xs)<br />addExpected x (<span class="dt">UnknownError</span> _) <span class="fu">=</span> <span class="dt">Expected</span> [x]<br />addExpected x (<span class="dt">Unexpected</span> _) <span class="fu">=</span> <span class="dt">Expected</span> [x]</code></pre>
<p>Ćwiczenie: zmodyfikuj swoje rozwiązanie poprzedniego ćwiczenia by działało jak Parsec:</p>
<pre><code>Prelude Text.Parsec&gt; parse digit &quot;&quot; &quot;&quot;
Left (line 1, column 1):
unexpected end of input
expecting digit
</code></pre>
<h1 id="usprawnianie">Usprawnianie</h1>
<pre class="sourceCode"><code class="sourceCode haskell">gen <span class="dv">0</span> <span class="fu">=</span> <span class="st">&quot;1&quot;</span><br />gen n <span class="fu">=</span> (<span class="ch">'1'</span><span class="fu">:</span><span class="ch">'+'</span><span class="fu">:</span><span class="ch">'1'</span><span class="fu">:</span><span class="ch">'-'</span><span class="fu">:</span>gen (n<span class="fu">-</span><span class="dv">1</span>))<br /><br /><span class="ot">pNum </span><span class="ot">::</span> <span class="dt">Parser</span> <span class="dt">Int</span><br />pNum <span class="fu">=</span> <span class="fu">fmap</span> <span class="fu">digitToInt</span> digit<br /><br />pExp <span class="fu">=</span> pNum <span class="ot">`chainl1`</span> addop<br />addop   <span class="fu">=</span>   <span class="kw">do</span>{ char <span class="ch">'+'</span>; <span class="fu">return</span> (<span class="fu">+</span>) }<br />          <span class="fu">&lt;|&gt;</span> <span class="kw">do</span>{ char <span class="ch">'-'</span>; <span class="fu">return</span> (<span class="fu">-</span>) }<br /><br />test n <span class="fu">=</span>  parse pExp <span class="st">&quot;gen&quot;</span> (gen n)</code></pre>
<p>Parsec jest szybszy niz nasze kombinatory:</p>
<pre><code>parsec 3:
benchmarking gen 1e5
collecting 100 samples, 1 iterations each, in estimated 8.396387 s
mean: 108.4311 ms, lb 104.1851 ms, ub 112.6549 ms, ci 0.950
std dev: 21.71925 ms, lb 20.55811 ms, ub 23.11727 ms, ci 0.950

MyParsec2a:
benchmarking gen 100000
collecting 100 samples, 1 iterations each, in estimated 13.94670 s
mean: 138.7350 ms, lb 136.4866 ms, ub 141.5722 ms, ci 0.950
</code></pre>
<p>Szczegóły: pmresults.txt</p>
<h1 id="koszt-alternatywy">Koszt alternatywy</h1>
<p>Alternatywa jest kosztowna:</p>
<pre class="sourceCode"><code class="sourceCode haskell">parserPlus p q <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p s <span class="kw">of</span><br />  <span class="dt">Error</span> e <span class="ot">-&gt;</span> runParser q s<br />  ok <span class="ot">-&gt;</span> ok</code></pre>
<p>Wejście dla <code>q</code> nie może zostać zwolnione zanim <code>p</code> się nie skończy - potencjalny wyciek pamięci.</p>
<p>Idea: przy alternatywie <code>p &lt;|&gt; q</code> uzywamy <code>q</code> tylko gdy <code>p</code> zawodzi nie konsumując wejścia.</p>
<p>Wtedy możemy zwolnić wejście dla <code>q</code>, gdy tylko <code>p</code> skonsumuje choć jeden znak.</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Consumed</span> a <span class="fu">=</span> <span class="dt">Consumed</span> (<span class="dt">Reply</span> a)<br />                <span class="fu">|</span> <span class="dt">Empty</span> (<span class="dt">Reply</span> a)<br /><br /><span class="ot">parserPlus </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a<br />parserPlus p q <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p s <span class="kw">of</span><br />  <span class="dt">Empty</span> (<span class="dt">Error</span> e) <span class="ot">-&gt;</span> runParser q s<br />  <span class="dt">Empty</span> ok <span class="ot">-&gt;</span> <span class="dt">Empty</span> ok<br />  consumed <span class="ot">-&gt;</span> consumed</code></pre>
<h1 id="implementacja">Implementacja</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="co">-- Code/Parse1/MyParsec2c</span><br /><span class="kw">data</span> <span class="dt">Consumed</span> a <span class="fu">=</span> <span class="dt">Consumed</span> (<span class="dt">Reply</span> a)<br />                <span class="fu">|</span> <span class="dt">Empty</span> (<span class="dt">Reply</span> a)<br /><br /><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> {<span class="ot"> runParser </span><span class="ot">::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Consumed</span> a }<br /><br />satisfy p <span class="fu">=</span> <span class="dt">Parser</span> sat' <span class="kw">where</span> <br />  sat' []    <span class="fu">=</span> <span class="dt">Empty</span>(<span class="dt">Error</span> (expected <span class="st">&quot;EOF&quot;</span>)) <span class="co">-- or check (p EOF)</span><br />  sat' (a<span class="fu">:</span>s) <span class="fu">=</span> <span class="kw">if</span> (p a) <span class="kw">then</span> <span class="dt">Consumed</span>(<span class="dt">Ok</span> a s) <span class="kw">else</span> <br />                 <span class="dt">Empty</span>(<span class="dt">Error</span> (unexpected <span class="fu">$</span> <span class="fu">show</span> a) )</code></pre>
<h1 id="sekwencjonowanie">Sekwencjonowanie</h1>
<p>Clou programu:</p>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span><br />  <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> <span class="dt">Empty</span>(<span class="dt">Ok</span> a s)<br /><br />  p <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \st <span class="ot">-&gt;</span> <span class="kw">case</span> runParser p st <span class="kw">of</span><br />      <span class="dt">Empty</span> reply <span class="ot">-&gt;</span> <span class="kw">case</span> reply <span class="kw">of</span><br />        <span class="dt">Ok</span> a s' <span class="ot">-&gt;</span> runParser (k a) s'<br />        <span class="dt">Error</span> e <span class="ot">-&gt;</span> <span class="dt">Empty</span> <span class="fu">$</span> <span class="dt">Error</span> e<br />      <span class="dt">Consumed</span> reply <span class="ot">-&gt;</span> <span class="dt">Consumed</span> (<span class="kw">case</span> reply <span class="kw">of</span><br />        <span class="dt">Ok</span> a s' <span class="ot">-&gt;</span> <span class="kw">case</span> runParser (k a) s' <span class="kw">of</span><br />                      <span class="dt">Empty</span> r <span class="ot">-&gt;</span> r<br />                      <span class="dt">Consumed</span> r <span class="ot">-&gt;</span> r<br />        <span class="dt">Error</span> e <span class="ot">-&gt;</span> <span class="dt">Error</span> e)</code></pre>
<p>Jeżeli <code>p</code> konsumuje wejście, to <code>p &gt;&gt;= k</code> obliczy się do <code>Consumed x</code>, a x pozostanie nie obliczone (z uwagi na leniwość!). Operacje <code>Parser/runParser</code> zostaną wyoptymalizowane (uwaga: <code>newtype</code>)</p>
<p>Zatem <code>(p &gt;&gt; długieobliczenie) &lt;|&gt; q</code> może zwolnić <code>q</code> i wejście dla niego gdy tylko <code>p</code> skonsumuje pierwszy znak, nie czekając aż zakończy się <code>długieobliczenie</code>.</p>
<h1 id="benchmark">Benchmark</h1>
<pre><code>GHCOPTS=-O -rtsopts
pm2c +RTS -s -RTS:
benchmarking gen 100000
mean: 40.95024 ms, lb 39.81659 ms, ub 42.13325 ms
   4,815,377,360 bytes allocated in the heap
   2,136,425,484 bytes copied during GC
       6,267,672 bytes maximum residency (343 sample(s))
              21 MB total memory in use (0 MB lost due to fragmentation)
  MUT     time   11.19s  ( 12.45s elapsed)
  GC      time    4.36s  (  4.53s elapsed)

pm2a +RTS -s -RTS:
benchmarking gen 100000
mean: 141.0365 ms, lb 138.7846 ms, ub 143.5224 ms
   7,535,812,664 bytes allocated in the heap
   4,317,341,644 bytes copied during GC
      16,940,736 bytes maximum residency (301 sample(s))
              47 MB total memory in use (0 MB lost due to fragmentation)
  MUT     time   10.31s  ( 11.32s elapsed)
  GC      time    8.23s  (  8.72s elapsed)
</code></pre>
<h1 id="parsec3-kontynuacje">Parsec3: kontynuacje</h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parsec</span> a <span class="fu">=</span> <span class="dt">Parsec</span> {<span class="ot"> unParser </span><span class="ot">::</span> forall b<span class="fu">.</span><br />                                 <span class="dt">State</span><br />                              <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> b) <span class="co">--  cok</span><br />                              <span class="ot">-&gt;</span> (<span class="dt">ParseError</span> <span class="ot">-&gt;</span> b) <span class="co">--  cerr</span><br />                              <span class="ot">-&gt;</span> b<br />                            }<br /><br />item' [] cok cerr <span class="fu">=</span> cerr (unexpected <span class="st">&quot;EOF&quot;</span>)<br />item' (x<span class="fu">:</span>xs) cok cerr <span class="fu">=</span> cok x xs<br />item <span class="fu">=</span> <span class="dt">Parsec</span> item'<br /><br /><span class="ot">eof </span><span class="ot">::</span> a <span class="ot">-&gt;</span> <span class="dt">Parsec</span> a<br />eof a <span class="fu">=</span> <span class="dt">Parsec</span> eof' <span class="kw">where</span><br />  eof' [] cok cerr <span class="fu">=</span> cok a []<br />  eof' _ cok cerr <span class="fu">=</span> cerr (expected <span class="st">&quot;EOF&quot;</span>)</code></pre>
<h1 id="section"></h1>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="kw">Monad</span> <span class="dt">Parser</span> <span class="kw">where</span><br />  <span class="fu">return</span> a <span class="fu">=</span> <span class="dt">Parser</span> (pure a) <span class="kw">where</span><br />    pure a s cok _ <span class="fu">=</span> cok a s<br /><br />  m <span class="fu">&gt;&gt;=</span> k <span class="fu">=</span> <span class="dt">Parser</span> (bind m k) <span class="kw">where</span> <br />    bind (<span class="dt">Parser</span> f) k s cok cerr <span class="fu">=</span> f s mcok cerr <span class="kw">where</span><br />      mcok a s <span class="fu">=</span> runParser (k a) s cok cerr<br />      mcerr <span class="fu">=</span> <span class="fu">undefined</span><br /><br /><span class="ot">parserPlus </span><span class="ot">::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a<br />parserPlus p q <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \s cok cerr <span class="ot">-&gt;</span> <span class="kw">let</span><br />    pok <span class="fu">=</span> cok<br />    perr <span class="fu">=</span> \e <span class="ot">-&gt;</span> runParser q s cok cerr<br /> <span class="kw">in</span> runParser p s pok perr </code></pre>
<h1 id="benchmark-1">Benchmark</h1>
<pre><code>GHCOPTS=-O -rtsopts
pm2c +RTS -s -RTS:
benchmarking gen 100000
mean: 40.95024 ms, lb 39.81659 ms, ub 42.13325 ms
   4,815,377,360 bytes allocated in the heap
   2,136,425,484 bytes copied during GC
       6,267,672 bytes maximum residency (343 sample(s))
              21 MB total memory in use (0 MB lost due to fragmentation)

pm3a +RTS -s -RTS:
benchmarking gen 100000
mean: 35.37689 ms, lb 34.61368 ms, ub 36.20859 ms
   4,209,433,272 bytes allocated in the heap
   2,128,069,148 bytes copied during GC
       6,234,896 bytes maximum residency (309 sample(s))
              21 MB total memory in use (0 MB lost due to fragmentation)
</code></pre>
<h1 id="&#263;wiczenie">Ćwiczenie</h1>
<ul>
<li><p>Ćwiczenie: połączyć pomysły 2c (Empty/Consumed) i 3a (kontynuacje) ewentualnie można jeszcze dołożyć 2b (obsługa błędów).</p></li>
<li><p>Wskazówka:</p></li>
</ul>
<pre class="sourceCode"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Parser</span> a <span class="fu">=</span> <span class="dt">Parser</span> {<span class="ot">unParser </span><span class="ot">::</span> forall b <span class="fu">.</span><br />                 <span class="dt">State</span><br />              <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">ParseError</span> <span class="ot">-&gt;</span> b) <span class="co">-- consumed ok</span><br />              <span class="ot">-&gt;</span> (<span class="dt">ParseError</span> <span class="ot">-&gt;</span> b)               <span class="co">-- consumed err</span><br />              <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">ParseError</span> <span class="ot">-&gt;</span> b) <span class="co">-- empty ok</span><br />              <span class="ot">-&gt;</span> (<span class="dt">ParseError</span> <span class="ot">-&gt;</span> b)               <span class="co">-- empty err</span><br />              <span class="ot">-&gt;</span> b<br />             }</code></pre>
</body>
</html>
